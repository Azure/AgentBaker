package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/Azure/agentbaker/vulnerability-reporting-vms/config"
)

func createVulnerabilityReportingVms(ctx context.Context, vhdData []*VHD) error {
	subnetID, err := setUpAzureResources(ctx)
	if err != nil {
		return err
	}

	// check if VMs already exist within the timeframe
	vmsToDelete, err := existingVMs(ctx)
	if err != nil {
		return err
	}
	if vmsToDelete != nil {
		log.Printf("This run is recreating VMs that were created within the last %d days\n", config.Config.UselatestImageWithin)
		log.Printf("Deleting stale VMS: %s\n", vmsToDelete)
		err = deleteVms(ctx, vmsToDelete)
	}

	for _, vhd := range vhdData {
		if err := createVM(ctx, vhd, subnetID); err != nil {
			return err
		}
		if err := addAzSecPackExtensions(ctx, vhd.name); err != nil {
			return err
		}
	}
	return nil
}

// https://msazure.visualstudio.com/ASMDocs/_wiki/wikis/ASMDocs.wiki/179541/Linux-AzSecPack-AutoConfig-Onboarding-(manual-for-C-AI)?anchor=arm-template-element-for-azuresecuritylinuxagent-vm-extension
func addAzSecPackExtensions(ctx context.Context, vmName string) error {
	log.Printf("Add AzSecPack extension")
	// create AzSecPack resource group
	AzSecPackAutoConfigRG := "AzSecPackAutoConfigRG"
	if config.Config.Location == "westus" {
		AzSecPackAutoConfigRG = "AzSecPackAutoConfigUA-westus"
	}
	if err := createResourceGroup(ctx, AzSecPackAutoConfigRG); err != nil {
		return fmt.Errorf("failed to create AzSecPack resource group: %v", err)
	}

	// create AzSecPack managed identity
	identityName := fmt.Sprintf("AzSecPackAutoConfigUA-%s", config.Config.Location)
	identityResourceID, err := createManagedIdentity(ctx, identityName, AzSecPackAutoConfigRG, config.Config.Location)
	if err != nil {
		log.Printf("failed to create AzSecPack managed identity: %v", err)
		return err
	}
	log.Printf("Managed Identity Resource ID: %s\n", identityResourceID)
	if identityResourceID == "" {
		log.Printf("failed to get AzSecPack managed identity managed identity resource ID")
		return err
	}

	if err := addManagedIdentityToVM(ctx, vmName, identityResourceID, config.ResourceGroupName); err != nil {
		return err
	}
	if err := createAzureMonitorLinuxAgentExtension(ctx, vmName); err != nil {
		return err
	}
	if err := createAzureSecurityLinuxAgentExtension(ctx, vmName); err != nil {
		return err
	}
	return nil
}

func setUpAzureResources(ctx context.Context) (string, error) {
	if err := createResourceGroup(ctx, config.ResourceGroupName); err != nil {
		return "", err
	}

	vnetName := "alison-test-vnet"
	if err := createVnet(ctx, vnetName); err != nil {
		return "", err
	}

	subnetName := "alison-test-subnet"
	subNetID, err := createSubnet(ctx, vnetName, subnetName)
	if err != nil {
		return "", err
	}
	return subNetID, nil
}

func existingVMs(ctx context.Context) ([]string, error) {
	vmsDate, err := listAllVMsWithCreationDate(ctx)
	if err != nil {
		return nil, err
	}
	currentDate, err := time.Parse("2006-01-02", config.CurrentDate)
	overwritePeriod := time.Now().AddDate(0, 0, -1*config.Config.UselatestImageWithin)
	log.Printf("Checking for VMs created between %s and %s\n", overwritePeriod, currentDate)

	vmsToDelete := []string{}
	for _, vm := range vmsDate {
		vmDate := vm.Date
		if !vmDate.Before(overwritePeriod) && !vmDate.After(currentDate) { // !vmDate makes it inclusive
			vmsToDelete = append(vmsToDelete, vm.Name)
		}
	}
	return vmsToDelete, nil
}
