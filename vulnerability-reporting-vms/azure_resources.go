package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/Azure/agentbaker/vulnerability-reporting-vms/config"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/msi/armmsi"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/network/armnetwork"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/resources/armresources"
)

func createVM(ctx context.Context, vhd *VHD, subnetID string) error {
	log.Printf("Creating VM %s in resource group %s\n", vhd, config.ResourceGroupName)

	vmSize := "Standard_D8ds_v5"
	if vhd.ImageArch == "Arm64" {
		vmSize = "Standard_D8pds_v5"
	}

	// create unique NIC for VM
	nicName := fmt.Sprintf("%s-nic", vhd.name)
	nicID, err := createNetworkInterface(ctx, nicName, subnetID)
	if err != nil {
		return fmt.Errorf("cannot create NIC: %v", err)
	}

	osDiskName := fmt.Sprintf("%s-osdisk", vhd.name)
	vmParameters := armcompute.VirtualMachine{
		Location: to.Ptr(config.Config.Location),
		Tags: map[string]*string{
			"azsecpack":    to.Ptr("prod"),
			"CreationDate": to.Ptr(config.CurrentDate),
		},
		Properties: &armcompute.VirtualMachineProperties{
			HardwareProfile: &armcompute.HardwareProfile{
				VMSize: to.Ptr(armcompute.VirtualMachineSizeTypes(vmSize)),
			},
			StorageProfile: &armcompute.StorageProfile{
				ImageReference: &armcompute.ImageReference{
					ID: to.Ptr(vhd.ResourceID),
				},
				OSDisk: &armcompute.OSDisk{
					Name:         to.Ptr(osDiskName),
					CreateOption: to.Ptr(armcompute.DiskCreateOptionTypesFromImage),
				},
			},
			OSProfile: &armcompute.OSProfile{
				ComputerName:  to.Ptr(vhd.name),
				AdminUsername: to.Ptr("azureuser"),
				AdminPassword: to.Ptr("Azure123!"), // TODO(alburgess) figure out what we want to do here
			},
			NetworkProfile: &armcompute.NetworkProfile{
				NetworkInterfaces: []*armcompute.NetworkInterfaceReference{
					{
						ID: to.Ptr(nicID),
					},
				},
			},
		},
	}

	log.Printf("Creating VM %s\n", vhd.name)
	pollerResp, err := config.Azure.VirtualMachinesClient.BeginCreateOrUpdate(ctx, config.ResourceGroupName, vhd.name, vmParameters, nil)
	if err != nil {
		return fmt.Errorf("cannot create VM: %v", err)
	}
	_, err = pollerResp.PollUntilDone(ctx, nil)
	if err != nil {
		return fmt.Errorf("cannot get the VM to create or update due to: %v", err)
	}

	log.Printf("VM %s created successfully\n", vhd.name)
	return nil
}

func createResourceGroup(ctx context.Context, resourceGroupName string) error {
	resourceGroupParams := armresources.ResourceGroup{
		Location: &config.Config.Location,
	}

	exists, err := checkResourceGroup(ctx, resourceGroupName)
	if err != nil {
		return fmt.Errorf("failed to check resource group: %v", err)
	}
	if exists {
		log.Printf("Resource group %s already exists\n", resourceGroupName)
		return nil
	}

	log.Printf("Creating resource group %s\n", resourceGroupName)
	_, err = config.Azure.ResourceGroupsClient.CreateOrUpdate(ctx, resourceGroupName, resourceGroupParams, nil)
	if err != nil {
		return fmt.Errorf("failed to create resource group: %v", err)
	}

	return nil
}

func checkResourceGroup(ctx context.Context, resourceGroupName string) (bool, error) {
	log.Printf("Checking if resource group %s exists\n", resourceGroupName)
	_, err := config.Azure.ResourceGroupsClient.Get(ctx, resourceGroupName, nil)
	if err != nil {
		var responseErr *azcore.ResponseError
		if errors.As(err, &responseErr) && responseErr.StatusCode == 404 {
			log.Printf("Resource group %s does not exist\n", resourceGroupName)
			return false, nil
		}
		return false, fmt.Errorf("failed to check resource group: %v", err)
	}
	return true, nil
}

func createVnet(ctx context.Context, vnetName string) error {
	log.Printf("Checking if VNet %s exists in resource group %s\n", vnetName, config.ResourceGroupName)
	_, err := config.Azure.VNetClient.Get(ctx, config.ResourceGroupName, vnetName, nil)
	if err == nil {
		log.Printf("VNet %s already exists in resource group %s\n", vnetName, config.ResourceGroupName)
		return nil
	}

	log.Printf("Creating VNet %s in resource group %s\n", vnetName, config.ResourceGroupName)
	vnetParams := armnetwork.VirtualNetwork{
		Location: &config.Config.Location,
		Properties: &armnetwork.VirtualNetworkPropertiesFormat{
			AddressSpace: &armnetwork.AddressSpace{
				AddressPrefixes: []*string{
					to.Ptr("10.0.0.0/16"),
				},
			},
		},
	}
	vnetPoller, err := config.Azure.VNetClient.BeginCreateOrUpdate(ctx, config.ResourceGroupName, vnetName, vnetParams, nil)
	if err != nil {
		return fmt.Errorf("failed to begin VNet creation: %v", err)
	}
	vnetResp, err := vnetPoller.PollUntilDone(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to create VNet: %v", err)
	}
	log.Printf("VNet %s created in resource group %s\n", *vnetResp.ID, config.ResourceGroupName)
	return nil
}

func createSubnet(ctx context.Context, vnetName, subnetName string) (string, error) {
	log.Printf("Checking if subnet %s exists in VNet %s\n", subnetName, vnetName)
	subnetResp, err := config.Azure.SubNetClient.Get(ctx, config.ResourceGroupName, vnetName, subnetName, nil)
	if err == nil {
		log.Printf("Subnet %s already exists in VNet %s\n", subnetName, vnetName)
		return *subnetResp.ID, nil
	}

	log.Printf("Creating subnet %s in VNet %s\n", subnetName, vnetName)
	subnetParams := armnetwork.Subnet{
		Properties: &armnetwork.SubnetPropertiesFormat{
			AddressPrefix: to.Ptr("10.0.1.0/24"),
		},
	}

	subnetPoller, err := config.Azure.SubNetClient.BeginCreateOrUpdate(ctx, config.ResourceGroupName, vnetName, subnetName, subnetParams, nil)
	if err != nil {
		return "", fmt.Errorf("failed to begin subnet creation: %v", err)
	}
	subResp, err := subnetPoller.PollUntilDone(ctx, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create subnet: %v", err)
	}
	log.Printf("Subnet %s created successfully\n", subnetName)
	return *subResp.ID, nil
}

func createNetworkInterface(ctx context.Context, nicName, subnetID string) (string, error) {
	log.Printf("Creating NIC %s in subnet %s\n", nicName, subnetID)
	nicParams := armnetwork.Interface{
		Location: &config.Config.Location,
		Properties: &armnetwork.InterfacePropertiesFormat{
			IPConfigurations: []*armnetwork.InterfaceIPConfiguration{
				{
					Name: to.Ptr("ipconfig1"),
					Properties: &armnetwork.InterfaceIPConfigurationPropertiesFormat{
						Subnet: &armnetwork.Subnet{ID: &subnetID},
					},
				},
			},
		},
	}
	poller, err := config.Azure.NetworkInterfacesClient.BeginCreateOrUpdate(ctx, config.ResourceGroupName, nicName, nicParams, nil)
	if err != nil {
		return "", fmt.Errorf("failed to begin NIC creation: %v", err)
	}
	nicResp, err := poller.PollUntilDone(ctx, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create NIC: %v", err)
	}
	log.Printf("NIC %s created successfully\n", nicName)
	return *nicResp.ID, nil
}

func createManagedIdentity(ctx context.Context, identityName, resourceGroupName, region string) (string, error) {
	identityParams := armmsi.Identity{
		Location: &region,
	}

	getResp, err := config.Azure.UserAssignedIdentityClient.Get(ctx, resourceGroupName, identityName, nil)
	if err == nil {
		log.Printf("Managed Identity %s already exists\n", identityName)
		return *getResp.ID, nil
	}

	createResp, err := config.Azure.UserAssignedIdentityClient.CreateOrUpdate(ctx, resourceGroupName, identityName, identityParams, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create managed identity: %v", err)
	}

	log.Printf("Managed Identity created successfully\n")
	return *createResp.ID, nil
}

func addManagedIdentityToVM(ctx context.Context, vmName, identityResourceID, resourceGroupName string) error {
	log.Printf("Adding managed identity %s to VM %s\n", identityResourceID, vmName)
	params := armcompute.VirtualMachineUpdate{
		Identity: &armcompute.VirtualMachineIdentity{
			Type: to.Ptr(armcompute.ResourceIdentityTypeUserAssigned),
			UserAssignedIdentities: map[string]*armcompute.UserAssignedIdentitiesValue{
				identityResourceID: {},
			},
		},
	}

	poller, err := config.Azure.VirtualMachinesClient.BeginUpdate(ctx, resourceGroupName, vmName, params, nil)
	if err != nil {
		return fmt.Errorf("failed to being update the managed identity to the VM: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to update the managed identity to the VM: %v", err)
	}
	log.Printf("Managed identity added to VM %s\n", vmName)
	return nil
}

func createAzureMonitorLinuxAgentExtension(ctx context.Context, vmName string) error {
	log.Printf("Adding AzureMonitorLinuxAgent extension to VM %s\n", vmName)
	extensionName := "AzureMonitorLinuxAgent"

	parameters := armcompute.VirtualMachineExtension{
		Location: to.Ptr(config.Config.Location),
		Properties: &armcompute.VirtualMachineExtensionProperties{
			Publisher:               to.Ptr("Microsoft.Azure.Monitor"),
			Type:                    to.Ptr("AzureMonitorLinuxAgent"),
			TypeHandlerVersion:      to.Ptr("1.0"),
			AutoUpgradeMinorVersion: to.Ptr(true),
			EnableAutomaticUpgrade:  to.Ptr(true),
			Settings: map[string]interface{}{
				"GCS_AUTO_CONFIG": true,
			},
		},
	}
	poller, err := config.Azure.ExtensionsClient.BeginCreateOrUpdate(ctx,
		config.ResourceGroupName,
		vmName,
		extensionName,
		parameters,
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to begin creating Azure Monitor Linux Agent extension: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to create Azure Monitor Linux Agent extension: %v", err)
	}
	return nil
}

func createAzureSecurityLinuxAgentExtension(ctx context.Context, vmName string) error {
	log.Printf("Adding AzureSecurityLinuxAgent extension to VM %s\n", vmName)
	extensionName := "AzureSecurityLinuxAgent"

	parameters := armcompute.VirtualMachineExtension{
		Location: to.Ptr(config.Config.Location),
		Properties: &armcompute.VirtualMachineExtensionProperties{
			Publisher:               to.Ptr("Microsoft.Azure.Security.Monitoring"),
			Type:                    to.Ptr("AzureSecurityLinuxAgent"),
			TypeHandlerVersion:      to.Ptr("2.0"),
			AutoUpgradeMinorVersion: to.Ptr(true),
			EnableAutomaticUpgrade:  to.Ptr(true),
			Settings: map[string]interface{}{
				"enableGenevaUpload": true,
				"enableAutoConfig":   true,
			},
		},
	}
	poller, err := config.Azure.ExtensionsClient.BeginCreateOrUpdate(ctx,
		config.ResourceGroupName,
		vmName,
		extensionName,
		parameters,
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to begin creating Azure Security Linux Agent extension: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to create Azure Security Linux Agent extension: %v", err)
	}
	return nil
}

func deleteVM(ctx context.Context, vmName string) error {
	log.Printf("Deleting VM %s in resource group %s\n", vmName, config.ResourceGroupName)
	pollerResp, err := config.Azure.VirtualMachinesClient.BeginDelete(ctx, config.ResourceGroupName, vmName, nil)
	if err != nil {
		log.Fatalf("failed to begin deleting VM: %v", err)
	}
	_, err = pollerResp.PollUntilDone(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to delete VM: %v", err)
	}
	log.Printf("VM %s deleted successfully\n", vmName)
	return nil
}

func deleteNetworkInterface(ctx context.Context, vmName string) error {
	log.Printf("Deleting network interface for VM %s\n", vmName)

	nicName := fmt.Sprintf("%s-nic", vmName)
	pollerResp, err := config.Azure.NetworkInterfacesClient.BeginDelete(ctx, config.ResourceGroupName, nicName, nil)
	if err != nil {
		return fmt.Errorf("failed to begin deleting network interface: %v", err)
	}
	_, err = pollerResp.PollUntilDone(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to delete network interface: %v", err)
	}
	log.Printf("Network interface %s deleted successfully\n", nicName)

	return nil
}

func deleteDisk(ctx context.Context, vmName string) error {
	log.Printf("Deleting disks for VM %s\n", vmName)

	osDiskName := fmt.Sprintf("%s-osdisk", vmName)
	pollerResp, err := config.Azure.DiskClient.BeginDelete(ctx, config.ResourceGroupName, osDiskName, nil)
	if err != nil {
		return fmt.Errorf("failed to begin deleting OS disk: %v", err)
	}
	_, err = pollerResp.PollUntilDone(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to delete OS disk: %v", err)
	}
	log.Printf("OS disk %s deleted successfully\n", osDiskName)
	return nil
}

func listAllVMsWithCreationDate(ctx context.Context) ([]VMDate, error) {
	log.Printf("Gathering all VMs in resource group %s\n", config.ResourceGroupName)

	vmsWithDate := []VMDate{}
	pager := config.Azure.VirtualMachinesClient.NewListPager(config.ResourceGroupName, nil)
	for pager.More() {
		page, err := pager.NextPage(ctx)
		if err != nil {
			return nil, err
		}
		for _, vm := range page.Value {
			creationDate, ok := vm.Tags["CreationDate"]
			if !ok || creationDate == nil {
				return nil, fmt.Errorf("VM %s does not have a creation date", *vm.Name)
			}

			parsedDate, err := time.Parse("2006-01-02", *creationDate)
			log.Printf("VM: %s, Date: %s\n", *vm.Name, parsedDate)
			if err != nil {
				return nil, err
			}
			vmsWithDate = append(vmsWithDate, VMDate{Name: *vm.Name, Date: parsedDate})
		}
	}
	return vmsWithDate, nil
}
