
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Azure/agentbaker/pkg/agent/baker.go (75.0%)</option>
				
				<option value="file1">github.com/Azure/agentbaker/pkg/agent/bakerapi.go (59.6%)</option>
				
				<option value="file2">github.com/Azure/agentbaker/pkg/agent/datamodel/helper.go (94.4%)</option>
				
				<option value="file3">github.com/Azure/agentbaker/pkg/agent/datamodel/mocks.go (7.7%)</option>
				
				<option value="file4">github.com/Azure/agentbaker/pkg/agent/datamodel/sig_config.go (53.0%)</option>
				
				<option value="file5">github.com/Azure/agentbaker/pkg/agent/datamodel/types.go (81.6%)</option>
				
				<option value="file6">github.com/Azure/agentbaker/pkg/agent/datamodel/versions.go (93.6%)</option>
				
				<option value="file7">github.com/Azure/agentbaker/pkg/agent/params.go (94.5%)</option>
				
				<option value="file8">github.com/Azure/agentbaker/pkg/agent/utils.go (80.9%)</option>
				
				<option value="file9">github.com/Azure/agentbaker/pkg/agent/variables.go (93.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package agent

import (
        "archive/zip"
        "bytes"
        "encoding/base64"
        "fmt"
        "reflect"
        "strings"
        "text/template"

        "github.com/Azure/agentbaker/pkg/agent/datamodel"
        "github.com/Azure/agentbaker/pkg/templates"
        "github.com/Azure/go-autorest/autorest/to"
)

// TemplateGenerator represents the object that performs the template generation.
type TemplateGenerator struct{}

// InitializeTemplateGenerator creates a new template generator object
func InitializeTemplateGenerator() *TemplateGenerator <span class="cov8" title="1">{
        t := &amp;TemplateGenerator{}
        return t
}</span>

// GetNodeBootstrappingPayload get node bootstrapping data
func (t *TemplateGenerator) GetNodeBootstrappingPayload(config *datamodel.NodeBootstrappingConfiguration) string <span class="cov8" title="1">{
        var customData string
        if config.AgentPoolProfile.IsWindows() </span><span class="cov8" title="1">{
                customData = getCustomDataFromJSON(t.getWindowsNodeCustomDataJSONObject(config))
        }</span> else<span class="cov8" title="1"> {
                customData = getCustomDataFromJSON(t.getLinuxNodeCustomDataJSONObject(config))
        }</span>
        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString([]byte(customData))</span>
}

// GetLinuxNodeCustomDataJSONObject returns Linux customData JSON object in the form
// { "customData": "&lt;customData string&gt;" }
func (t *TemplateGenerator) getLinuxNodeCustomDataJSONObject(config *datamodel.NodeBootstrappingConfiguration) string <span class="cov8" title="1">{
        // validate and fix input
        validateAndSetLinuxNodeBootstrappingConfiguration(config)
        // get parameters
        parameters := getParameters(config, "baker", "1.0")
        // get variable cloudInit
        variables := getCustomDataVariables(config)
        str, e := t.getSingleLineForTemplate(kubernetesNodeCustomDataYaml,
                config.AgentPoolProfile, getBakerFuncMap(config, parameters, variables))

        if e != nil </span><span class="cov0" title="0">{
                panic(e)</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("{\"customData\": \"%s\"}", str)</span>
}

// GetWindowsNodeCustomDataJSONObject returns Windows customData JSON object in the form
// { "customData": "&lt;customData string&gt;" }
func (t *TemplateGenerator) getWindowsNodeCustomDataJSONObject(config *datamodel.NodeBootstrappingConfiguration) string <span class="cov8" title="1">{
        // validate and fix input
        validateAndSetWindowsNodeBootstrappingConfiguration(config)

        cs := config.ContainerService
        profile := config.AgentPoolProfile
        // get parameters
        parameters := getParameters(config, "", "")
        // get variable custom data
        variables := getWindowsCustomDataVariables(config)
        str, e := t.getSingleLineForTemplate(kubernetesWindowsAgentCustomDataPS1,
                profile, getBakerFuncMap(config, parameters, variables))

        if e != nil </span><span class="cov0" title="0">{
                panic(e)</span>
        }

        <span class="cov8" title="1">preprovisionCmd := ""

        if profile.PreprovisionExtension != nil </span><span class="cov0" title="0">{
                preprovisionCmd = makeAgentExtensionScriptCommands(cs, profile)
        }</span>

        <span class="cov8" title="1">str = strings.Replace(str, "PREPROVISION_EXTENSION", escapeSingleLine(strings.TrimSpace(preprovisionCmd)), -1)
        return fmt.Sprintf("{\"customData\": \"%s\"}", str)</span>
}

// GetNodeBootstrappingCmd get node bootstrapping cmd
func (t *TemplateGenerator) GetNodeBootstrappingCmd(config *datamodel.NodeBootstrappingConfiguration) string <span class="cov8" title="1">{
        if config.AgentPoolProfile.IsWindows() </span><span class="cov8" title="1">{
                return t.getWindowsNodeCSECommand(config)
        }</span>
        <span class="cov8" title="1">return t.getLinuxNodeCSECommand(config)</span>
}

// getLinuxNodeCSECommand returns Linux node custom script extension execution command
func (t *TemplateGenerator) getLinuxNodeCSECommand(config *datamodel.NodeBootstrappingConfiguration) string <span class="cov8" title="1">{
        // validate and fix input
        validateAndSetLinuxNodeBootstrappingConfiguration(config)
        // get parameters
        parameters := getParameters(config, "", "")
        // get variable
        variables := getCSECommandVariables(config)
        // NOTE: that CSE command will be executed by VM/VMSS extension so it doesn't need extra escaping like custom data does
        str, e := t.getSingleLine(
                kubernetesCSECommandString,
                config.AgentPoolProfile,
                getBakerFuncMap(config, parameters, variables),
        )

        if e != nil </span><span class="cov0" title="0">{
                panic(e)</span>
        }
        // NOTE: we break the one-line CSE command into different lines in a file for better management
        // so we need to combine them into one line here
        <span class="cov8" title="1">return strings.Replace(str, "\n", " ", -1)</span>
}

// getWindowsNodeCSECommand returns Windows node custom script extension execution command
func (t *TemplateGenerator) getWindowsNodeCSECommand(config *datamodel.NodeBootstrappingConfiguration) string <span class="cov8" title="1">{
        // TODO(ace): linux cleans the input here for CSE now.
        // should we do the same for windows?
        // get parameters
        parameters := getParameters(config, "", "")
        // get variable
        variables := getCSECommandVariables(config)

        // NOTE: that CSE command will be executed by VMSS extension so it doesn't need extra escaping like custom data does
        str, e := t.getSingleLine(
                kubernetesWindowsAgentCSECommandPS1,
                config.AgentPoolProfile,
                getBakerFuncMap(config, parameters, variables),
        )

        if e != nil </span><span class="cov0" title="0">{
                panic(e)</span>
        }
        // NOTE(qinahao): windows cse cmd uses esapced \" to quote Powershell command in [csecmd.p1](https://github.com/Azure/AgentBaker/blob/master/parts/windows/csecmd.ps1)
        // to not break go template parsing. We switch \" back to " otherwise Azure ARM template will escape \ to be \\\"
        <span class="cov8" title="1">str = strings.Replace(str, `\"`, `"`, -1)

        // NOTE: we break the one-line CSE command into different lines in a file for better management
        // so we need to combine them into one line here
        return strings.Replace(str, "\n", " ", -1)</span>
}

// getSingleLineForTemplate returns the file as a single line for embedding in an arm template
func (t *TemplateGenerator) getSingleLineForTemplate(textFilename string, profile interface{},
        funcMap template.FuncMap,
) (string, error) <span class="cov8" title="1">{
        expandedTemplate, err := t.getSingleLine(textFilename, profile, funcMap)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">textStr := escapeSingleLine(expandedTemplate)

        return textStr, nil</span>
}

// getSingleLine returns the file as a single line
func (t *TemplateGenerator) getSingleLine(textFilename string, profile interface{},
        funcMap template.FuncMap,
) (string, error) <span class="cov8" title="1">{
        b, err := templates.Asset(textFilename)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("yaml file %s does not exist", textFilename)
        }</span>

        // use go templates to process the text filename
        <span class="cov8" title="1">templ := template.New("customdata template").Option("missingkey=zero").Funcs(funcMap)
        if _, err = templ.New(textFilename).Parse(string(b)); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error parsing file %s: %v", textFilename, err)
        }</span>

        <span class="cov8" title="1">var buffer bytes.Buffer
        if err = templ.ExecuteTemplate(&amp;buffer, textFilename, profile); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error executing template for file %s: %v", textFilename, err)
        }</span>
        <span class="cov8" title="1">expandedTemplate := buffer.String()

        return expandedTemplate, nil</span>
}

// getTemplateFuncMap returns the general purpose template func map from getContainerServiceFuncMap
func getBakerFuncMap(config *datamodel.NodeBootstrappingConfiguration, params paramsMap, variables paramsMap) template.FuncMap <span class="cov8" title="1">{
        funcMap := getContainerServiceFuncMap(config)

        funcMap["GetParameter"] = func(s string) interface{} </span><span class="cov8" title="1">{
                if v, ok := params[s].(paramsMap); ok &amp;&amp; v != nil </span><span class="cov8" title="1">{
                        if v["value"] == nil </span><span class="cov0" title="0">{
                                // return empty string so we don't get &lt;no value&gt; from go template
                                return ""
                        }</span>
                        <span class="cov8" title="1">return v["value"]</span>
                }
                <span class="cov8" title="1">return ""</span>
        }

        // TODO: GetParameterPropertyLower
        <span class="cov8" title="1">funcMap["GetParameterProperty"] = func(s, p string) interface{} </span><span class="cov8" title="1">{
                if v, ok := params[s].(paramsMap); ok &amp;&amp; v != nil </span><span class="cov8" title="1">{
                        if v["value"].(paramsMap)[p] == nil </span><span class="cov0" title="0">{
                                // return empty string so we don't get &lt;no value&gt; from go template
                                return ""
                        }</span>
                        <span class="cov8" title="1">return v["value"].(paramsMap)[p]</span>
                }
                <span class="cov8" title="1">return ""</span>
        }

        <span class="cov8" title="1">funcMap["GetVariable"] = func(s string) interface{} </span><span class="cov8" title="1">{
                if variables[s] == nil </span><span class="cov0" title="0">{
                        // return empty string so we don't get &lt;no value&gt; from go template
                        return ""
                }</span>
                <span class="cov8" title="1">return variables[s]</span>
        }

        <span class="cov8" title="1">funcMap["GetVariableProperty"] = func(v, p string) interface{} </span><span class="cov8" title="1">{
                if v, ok := variables[v].(paramsMap); ok &amp;&amp; v != nil </span><span class="cov8" title="1">{
                        if v[p] == nil </span><span class="cov8" title="1">{
                                // return empty string so we don't get &lt;no value&gt; from go template
                                return ""
                        }</span>
                        <span class="cov8" title="1">return v[p]</span>
                }
                <span class="cov0" title="0">return ""</span>
        }

        <span class="cov8" title="1">return funcMap</span>
}

// normalizeResourceGroupNameForLabel normalizes resource group name to be used as a label,
// similar to what the ARM template used to do.
//
// When ARM template was used, the following is used:
//
//        variables('labelResourceGroup')
//
// which is defined as:
//
//        [if(or(or(endsWith(variables('truncatedResourceGroup'), '-'), endsWith(variables('truncatedResourceGroup'), '_')), endsWith(variables('truncatedResourceGroup'), '.')), concat(take(variables('truncatedResourceGroup'), 62), 'z'), variables('truncatedResourceGroup'))]
//
// the "truncatedResourceGroup" is defined as:
//
//        [take(replace(replace(resourceGroup().name, '(', '-'), ')', '-'), 63)]
//
// This function does the same processing.
func normalizeResourceGroupNameForLabel(resourceGroupName string) string <span class="cov8" title="1">{
        truncated := resourceGroupName
        truncated = strings.ReplaceAll(truncated, "(", "-")
        truncated = strings.ReplaceAll(truncated, ")", "-")
        const maxLen = 63
        if len(truncated) &gt; maxLen </span><span class="cov8" title="1">{
                truncated = truncated[0:maxLen]
        }</span>

        <span class="cov8" title="1">if strings.HasSuffix(truncated, "-") ||
                strings.HasSuffix(truncated, "_") ||
                strings.HasSuffix(truncated, ".") </span><span class="cov8" title="1">{

                if len(truncated) &gt; 62 </span><span class="cov8" title="1">{
                        return truncated[0:len(truncated)-1] + "z"
                }</span> else<span class="cov8" title="1"> {
                        return truncated + "z"
                }</span>
        }
        <span class="cov8" title="1">return truncated</span>
}

func validateAndSetLinuxNodeBootstrappingConfiguration(config *datamodel.NodeBootstrappingConfiguration) <span class="cov8" title="1">{
        // If using kubelet config file, disable DynamicKubeletConfig feature gate and remove dynamic-config-dir
        // we should only allow users to configure from API (20201101 and later)
        profile := config.AgentPoolProfile
        if config.KubeletConfig != nil </span><span class="cov8" title="1">{
                kubeletFlags := config.KubeletConfig
                delete(kubeletFlags, "--dynamic-config-dir")
                delete(kubeletFlags, "--non-masquerade-cidr")
                if profile != nil &amp;&amp; profile.KubernetesConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntime != "" &amp;&amp; profile.KubernetesConfig.ContainerRuntime == "containerd" </span><span class="cov8" title="1">{
                        for _, flag := range dockerShimFlags </span><span class="cov8" title="1">{
                                delete(kubeletFlags, flag)
                        }</span>
                }
                <span class="cov8" title="1">if IsKubernetesVersionGe(config.ContainerService.Properties.OrchestratorProfile.OrchestratorVersion, "1.24.0") </span><span class="cov8" title="1">{
                        kubeletFlags["--feature-gates"] = removeFeatureGateString(kubeletFlags["--feature-gates"], "DynamicKubeletConfig")
                }</span> else<span class="cov8" title="1"> if IsKubernetesVersionGe(config.ContainerService.Properties.OrchestratorProfile.OrchestratorVersion, "1.11.0") </span><span class="cov8" title="1">{
                        kubeletFlags["--feature-gates"] = addFeatureGateString(kubeletFlags["--feature-gates"], "DynamicKubeletConfig", false)
                }</span>

                // ContainerInsights depends on GPU accelerator Usage metrics from Kubelet cAdvisor endpoint but deprecation of this feature moved to beta which breaks the ContainerInsights customers with K8s version 1.20 or higher
                // Until Container Insights move to new API adding this feature gate to get the GPU metrics continue to work
                // Reference - https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/1867-disable-accelerator-usage-metrics
                <span class="cov8" title="1">if IsKubernetesVersionGe(config.ContainerService.Properties.OrchestratorProfile.OrchestratorVersion, "1.20.0") &amp;&amp;
                        !IsKubernetesVersionGe(config.ContainerService.Properties.OrchestratorProfile.OrchestratorVersion, "1.25.0") </span><span class="cov8" title="1">{
                        kubeletFlags["--feature-gates"] = addFeatureGateString(kubeletFlags["--feature-gates"], "DisableAcceleratorUsageMetrics", false)
                }</span>
        }
}

func validateAndSetWindowsNodeBootstrappingConfiguration(config *datamodel.NodeBootstrappingConfiguration) <span class="cov8" title="1">{
        if IsKubeletClientTLSBootstrappingEnabled(config.KubeletClientTLSBootstrapToken) </span><span class="cov8" title="1">{
                // backfill proper flags for Windows agent node TLS bootstrapping
                if config.KubeletConfig == nil </span><span class="cov0" title="0">{
                        config.KubeletConfig = make(map[string]string)
                }</span>

                <span class="cov8" title="1">config.KubeletConfig["--bootstrap-kubeconfig"] = "c:\\k\\bootstrap-config"
                config.KubeletConfig["--cert-dir"] = "c:\\k\\pki"</span>
        }
        <span class="cov8" title="1">if config.KubeletConfig != nil </span><span class="cov8" title="1">{
                kubeletFlags := config.KubeletConfig
                delete(kubeletFlags, "--dynamic-config-dir")
                if IsKubernetesVersionGe(config.ContainerService.Properties.OrchestratorProfile.OrchestratorVersion, "1.24.0") </span><span class="cov0" title="0">{
                        kubeletFlags["--feature-gates"] = removeFeatureGateString(kubeletFlags["--feature-gates"], "DynamicKubeletConfig")
                }</span> else<span class="cov8" title="1"> if IsKubernetesVersionGe(config.ContainerService.Properties.OrchestratorProfile.OrchestratorVersion, "1.11.0") </span><span class="cov8" title="1">{
                        kubeletFlags["--feature-gates"] = addFeatureGateString(kubeletFlags["--feature-gates"], "DynamicKubeletConfig", false)
                }</span>
        }
}

// getContainerServiceFuncMap returns all functions used in template generation
// These funcs are a thin wrapper for template generation operations,
// all business logic is implemented in the underlying func
func getContainerServiceFuncMap(config *datamodel.NodeBootstrappingConfiguration) template.FuncMap <span class="cov8" title="1">{
        cs := config.ContainerService
        profile := config.AgentPoolProfile
        return template.FuncMap{
                "Disable1804SystemdResolved": func() bool </span><span class="cov0" title="0">{
                        return config.Disable1804SystemdResolved
                }</span>,
                // This was DisableUnattendedUpgrade when we had UU enabled by default in image.
                // Now we don't, so we have to deliberately enable it.
                // Someone smarter than me can fix the API.
                "EnableUnattendedUpgrade": func() bool <span class="cov8" title="1">{
                        return !config.DisableUnattendedUpgrades
                }</span>,
                "IsIPMasqAgentEnabled": func() bool <span class="cov0" title="0">{
                        return cs.Properties.IsIPMasqAgentEnabled()
                }</span>,
                "IsKubernetesVersionGe": func(version string) bool <span class="cov8" title="1">{
                        return cs.Properties.OrchestratorProfile.IsKubernetes() &amp;&amp; IsKubernetesVersionGe(cs.Properties.OrchestratorProfile.OrchestratorVersion, version)
                }</span>,
                "GetAgentKubernetesLabels": func(profile *datamodel.AgentPoolProfile) string <span class="cov8" title="1">{
                        return profile.GetKubernetesLabels(normalizeResourceGroupNameForLabel(config.ResourceGroupName),
                                false, config.EnableNvidia, config.FIPSEnabled, config.OSSKU)
                }</span>,
                "GetAgentKubernetesLabelsDeprecated": func(profile *datamodel.AgentPoolProfile) string <span class="cov8" title="1">{
                        return profile.GetKubernetesLabels(normalizeResourceGroupNameForLabel(config.ResourceGroupName),
                                true, config.EnableNvidia, config.FIPSEnabled, config.OSSKU)
                }</span>,
                "GetGPUInstanceProfile": func() string <span class="cov8" title="1">{
                        return config.GPUInstanceProfile
                }</span>,
                "IsMIGEnabledNode": func() bool <span class="cov0" title="0">{
                        return config.GPUInstanceProfile != ""
                }</span>,
                "GetKubeletConfigFileContent": func() string <span class="cov0" title="0">{
                        return GetKubeletConfigFileContent(config.KubeletConfig, profile.CustomKubeletConfig)
                }</span>,
                "GetKubeletConfigFileContentBase64": func() string <span class="cov8" title="1">{
                        return base64.StdEncoding.EncodeToString([]byte(GetKubeletConfigFileContent(config.KubeletConfig, profile.CustomKubeletConfig)))
                }</span>,
                "IsKubeletConfigFileEnabled": func() bool <span class="cov8" title="1">{
                        return IsKubeletConfigFileEnabled(cs, profile, config.EnableKubeletConfigFile)
                }</span>,
                "IsKubeletClientTLSBootstrappingEnabled": func() bool <span class="cov8" title="1">{
                        return IsKubeletClientTLSBootstrappingEnabled(config.KubeletClientTLSBootstrapToken)
                }</span>,
                "GetTLSBootstrapTokenForKubeConfig": func() string <span class="cov8" title="1">{
                        return GetTLSBootstrapTokenForKubeConfig(config.KubeletClientTLSBootstrapToken)
                }</span>,
                "GetKubeletConfigKeyVals": func() string <span class="cov8" title="1">{
                        return GetOrderedKubeletConfigFlagString(config.KubeletConfig, cs, profile, config.EnableKubeletConfigFile)
                }</span>,
                "GetKubeletConfigKeyValsPsh": func() string <span class="cov8" title="1">{
                        return config.GetOrderedKubeletConfigStringForPowershell(profile.CustomKubeletConfig)
                }</span>,
                "GetKubeproxyConfigKeyValsPsh": func() string <span class="cov8" title="1">{
                        return config.GetOrderedKubeproxyConfigStringForPowershell()
                }</span>,
                "Is2204VHD": func() bool <span class="cov8" title="1">{
                        return profile.Is2204VHDDistro()
                }</span>,
                "GetKubeProxyFeatureGatesPsh": func() string <span class="cov8" title="1">{
                        return cs.Properties.GetKubeProxyFeatureGatesWindowsArguments()
                }</span>,
                "ShouldConfigCustomSysctl": func() bool <span class="cov8" title="1">{
                        return profile.CustomLinuxOSConfig != nil &amp;&amp; profile.CustomLinuxOSConfig.Sysctls != nil
                }</span>,
                "GetCustomSysctlConfigByName": func(fn string) interface{} <span class="cov8" title="1">{
                        if profile.CustomLinuxOSConfig != nil &amp;&amp; profile.CustomLinuxOSConfig.Sysctls != nil </span><span class="cov8" title="1">{
                                v := reflect.ValueOf(*profile.CustomLinuxOSConfig.Sysctls)
                                return v.FieldByName(fn).Interface()
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
                "ShouldConfigTransparentHugePage": func() bool <span class="cov8" title="1">{
                        return profile.CustomLinuxOSConfig != nil &amp;&amp; (profile.CustomLinuxOSConfig.TransparentHugePageEnabled != "" || profile.CustomLinuxOSConfig.TransparentHugePageDefrag != "")
                }</span>,
                "GetTransparentHugePageEnabled": func() string <span class="cov8" title="1">{
                        if profile.CustomLinuxOSConfig == nil </span><span class="cov8" title="1">{
                                return ""
                        }</span>
                        <span class="cov8" title="1">return profile.CustomLinuxOSConfig.TransparentHugePageEnabled</span>
                },
                "GetTransparentHugePageDefrag": func() string <span class="cov8" title="1">{
                        if profile.CustomLinuxOSConfig == nil </span><span class="cov8" title="1">{
                                return ""
                        }</span>
                        <span class="cov8" title="1">return profile.CustomLinuxOSConfig.TransparentHugePageDefrag</span>
                },
                "ShouldConfigSwapFile": func() bool <span class="cov8" title="1">{
                        // only configure swap file when FailSwapOn is false and SwapFileSizeMB is valid
                        return profile.CustomKubeletConfig != nil &amp;&amp; profile.CustomKubeletConfig.FailSwapOn != nil &amp;&amp; !*profile.CustomKubeletConfig.FailSwapOn &amp;&amp;
                                profile.CustomLinuxOSConfig != nil &amp;&amp; profile.CustomLinuxOSConfig.SwapFileSizeMB != nil &amp;&amp; *profile.CustomLinuxOSConfig.SwapFileSizeMB &gt; 0
                }</span>,
                "GetSwapFileSizeMB": func() int32 <span class="cov8" title="1">{
                        if profile.CustomLinuxOSConfig != nil &amp;&amp; profile.CustomLinuxOSConfig.SwapFileSizeMB != nil </span><span class="cov8" title="1">{
                                return *profile.CustomLinuxOSConfig.SwapFileSizeMB
                        }</span>
                        <span class="cov8" title="1">return 0</span>
                },
                "IsKubernetes": func() bool <span class="cov0" title="0">{
                        return cs.Properties.OrchestratorProfile.IsKubernetes()
                }</span>,
                "GetKubernetesEndpoint": func() string <span class="cov8" title="1">{
                        if cs.Properties.HostedMasterProfile == nil </span><span class="cov0" title="0">{
                                return ""
                        }</span>
                        <span class="cov8" title="1">if cs.Properties.HostedMasterProfile.IPAddress != "" </span><span class="cov8" title="1">{
                                return cs.Properties.HostedMasterProfile.IPAddress
                        }</span>
                        <span class="cov8" title="1">return cs.Properties.HostedMasterProfile.FQDN</span>
                },
                "IsAzureCNI": func() bool <span class="cov0" title="0">{
                        return cs.Properties.OrchestratorProfile.IsAzureCNI()
                }</span>,
                "IsNoneCNI": func() bool <span class="cov0" title="0">{
                        return cs.Properties.OrchestratorProfile.IsNoneCNI()
                }</span>,
                "IsMariner": func() bool <span class="cov8" title="1">{
                        // TODO(ace): do we care about both? 2nd one should be more general and catch custom VHD for mariner
                        return profile.Distro.IsCBLMarinerDistro() || isMariner(config.OSSKU)
                }</span>,
                "IsKata": func() bool <span class="cov8" title="1">{
                        return profile.Distro.IsKataDistro()
                }</span>,
                "EnableHostsConfigAgent": func() bool <span class="cov8" title="1">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig != nil &amp;&amp;
                                cs.Properties.OrchestratorProfile.KubernetesConfig.PrivateCluster != nil &amp;&amp;
                                to.Bool(cs.Properties.OrchestratorProfile.KubernetesConfig.PrivateCluster.EnableHostsConfigAgent)
                }</span>,
                "UseManagedIdentity": func() bool <span class="cov0" title="0">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.UseManagedIdentity
                }</span>,
                "GetSshPublicKeysPowerShell": func() string <span class="cov8" title="1">{
                        return getSSHPublicKeysPowerShell(cs.Properties.LinuxProfile)
                }</span>,
                "GetKubernetesAgentPreprovisionYaml": func(profile *datamodel.AgentPoolProfile) string <span class="cov0" title="0">{
                        str := ""
                        if profile.PreprovisionExtension != nil </span><span class="cov0" title="0">{
                                str += "\n"
                                str += makeAgentExtensionScriptCommands(cs, profile)
                        }</span>
                        <span class="cov0" title="0">return str</span>
                },
                "GetKubernetesWindowsAgentFunctions": func() string <span class="cov8" title="1">{
                        // Collect all the parts into a zip
                        parts := []string{
                                kubernetesWindowsCSEHelperPS1,
                                kubernetesWindowsSendLogsPS1,
                        }

                        // Create a buffer, new zip
                        buf := new(bytes.Buffer)
                        zw := zip.NewWriter(buf)

                        for _, part := range parts </span><span class="cov8" title="1">{
                                f, err := zw.Create(part)
                                if err != nil </span><span class="cov0" title="0">{
                                        panic(err)</span>
                                }
                                <span class="cov8" title="1">partContents, err := templates.Asset(part)
                                if err != nil </span><span class="cov0" title="0">{
                                        panic(err)</span>
                                }
                                <span class="cov8" title="1">_, err = f.Write(partContents)
                                if err != nil </span><span class="cov0" title="0">{
                                        panic(err)</span>
                                }
                        }
                        <span class="cov8" title="1">err := zw.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString(buf.Bytes())</span>
                },
                "IsNSeriesSKU": func() bool <span class="cov8" title="1">{
                        return config.EnableNvidia
                }</span>,
                "HasCustomSearchDomain": func() bool <span class="cov8" title="1">{
                        return cs.Properties.LinuxProfile != nil &amp;&amp; cs.Properties.LinuxProfile.HasSearchDomain()
                }</span>,
                "GetSearchDomainName": func() string <span class="cov8" title="1">{
                        if cs.Properties.LinuxProfile != nil &amp;&amp; cs.Properties.LinuxProfile.HasSearchDomain() </span><span class="cov0" title="0">{
                                return cs.Properties.LinuxProfile.CustomSearchDomain.Name
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "GetSearchDomainRealmUser": func() string <span class="cov8" title="1">{
                        if cs.Properties.LinuxProfile != nil &amp;&amp; cs.Properties.LinuxProfile.HasSearchDomain() </span><span class="cov0" title="0">{
                                return cs.Properties.LinuxProfile.CustomSearchDomain.RealmUser
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "GetSearchDomainRealmPassword": func() string <span class="cov8" title="1">{
                        if cs.Properties.LinuxProfile != nil &amp;&amp; cs.Properties.LinuxProfile.HasSearchDomain() </span><span class="cov0" title="0">{
                                return cs.Properties.LinuxProfile.CustomSearchDomain.RealmPassword
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "HasCalicoNetworkPolicy": func() bool <span class="cov8" title="1">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.NetworkPolicy == NetworkPolicyCalico
                }</span>,
                "HasAntreaNetworkPolicy": func() bool <span class="cov0" title="0">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.NetworkPolicy == NetworkPolicyAntrea
                }</span>,
                "HasFlannelNetworkPlugin": func() bool <span class="cov0" title="0">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.NetworkPlugin == NetworkPluginFlannel
                }</span>,
                "HasKubeletClientKey": func() bool <span class="cov0" title="0">{
                        return cs.Properties.CertificateProfile != nil &amp;&amp; cs.Properties.CertificateProfile.ClientPrivateKey != ""
                }</span>,
                "GetKubeletClientKey": func() string <span class="cov8" title="1">{
                        if cs.Properties.CertificateProfile != nil &amp;&amp; cs.Properties.CertificateProfile.ClientPrivateKey != "" </span><span class="cov0" title="0">{
                                encoded := base64.StdEncoding.EncodeToString([]byte(cs.Properties.CertificateProfile.ClientPrivateKey))
                                return encoded
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "GetKubeletClientCert": func() string <span class="cov8" title="1">{
                        if cs.Properties.CertificateProfile != nil &amp;&amp; cs.Properties.CertificateProfile.ClientCertificate != "" </span><span class="cov0" title="0">{
                                encoded := base64.StdEncoding.EncodeToString([]byte(cs.Properties.CertificateProfile.ClientCertificate))
                                return encoded
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "HasServicePrincipalSecret": func() bool <span class="cov0" title="0">{
                        return cs.Properties.ServicePrincipalProfile != nil &amp;&amp; cs.Properties.ServicePrincipalProfile.Secret != ""
                }</span>,
                "GetServicePrincipalSecret": func() string <span class="cov8" title="1">{
                        if cs.Properties.ServicePrincipalProfile != nil &amp;&amp; cs.Properties.ServicePrincipalProfile.Secret != "" </span><span class="cov8" title="1">{
                                encoded := base64.StdEncoding.EncodeToString([]byte(cs.Properties.ServicePrincipalProfile.Secret))
                                return encoded
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                },
                "WindowsSSHEnabled": func() bool <span class="cov8" title="1">{
                        return cs.Properties.WindowsProfile.GetSSHEnabled()
                }</span>,
                "IsIPv6DualStackFeatureEnabled": func() bool <span class="cov8" title="1">{
                        return cs.Properties.FeatureFlags.IsFeatureEnabled("EnableIPv6DualStack")
                }</span>,
                "IsAzureCNIOverlayFeatureEnabled": func() bool <span class="cov8" title="1">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.IsUsingNetworkPluginMode("overlay")
                }</span>,
                "GetBase64EncodedEnvironmentJSON": func() string <span class="cov8" title="1">{
                        customEnvironmentJSON, _ := cs.Properties.GetCustomEnvironmentJSON(false)
                        return base64.StdEncoding.EncodeToString([]byte(customEnvironmentJSON))
                }</span>,
                "GetIdentitySystem": func() string <span class="cov8" title="1">{
                        return datamodel.AzureADIdentitySystem
                }</span>,
                "GetPodInfraContainerSpec": func() string <span class="cov8" title="1">{
                        return config.K8sComponents.PodInfraContainerImageURL
                }</span>,
                "IsKubenet": func() bool <span class="cov8" title="1">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.NetworkPlugin == NetworkPluginKubenet
                }</span>,
                "NeedsContainerd": func() bool <span class="cov8" title="1">{
                        if profile != nil &amp;&amp; profile.KubernetesConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntime != "" </span><span class="cov8" title="1">{
                                return profile.KubernetesConfig.NeedsContainerd()
                        }</span>
                        <span class="cov8" title="1">return cs.Properties.OrchestratorProfile.KubernetesConfig.NeedsContainerd()</span>
                },
                "UseRuncShimV2": func() bool <span class="cov0" title="0">{
                        return config.EnableRuncShimV2
                }</span>,
                "IsDockerContainerRuntime": func() bool <span class="cov8" title="1">{
                        if profile != nil &amp;&amp; profile.KubernetesConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntime != "" </span><span class="cov8" title="1">{
                                return profile.KubernetesConfig.ContainerRuntime == datamodel.Docker
                        }</span>
                        <span class="cov8" title="1">return cs.Properties.OrchestratorProfile.KubernetesConfig.ContainerRuntime == datamodel.Docker</span>
                },
                "RequiresDocker": func() bool <span class="cov0" title="0">{
                        if profile != nil &amp;&amp; profile.KubernetesConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntime != "" </span><span class="cov0" title="0">{
                                return profile.KubernetesConfig.RequiresDocker()
                        }</span>
                        <span class="cov0" title="0">return cs.Properties.OrchestratorProfile.KubernetesConfig.RequiresDocker()</span>
                },
                "HasDataDir": func() bool <span class="cov8" title="1">{
                        if profile != nil &amp;&amp; profile.KubernetesConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntimeConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntimeConfig[datamodel.ContainerDataDirKey] != "" </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">if profile.KubeletDiskType == datamodel.TempDisk </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">return cs.Properties.OrchestratorProfile.KubernetesConfig.ContainerRuntimeConfig != nil &amp;&amp; cs.Properties.OrchestratorProfile.KubernetesConfig.ContainerRuntimeConfig[datamodel.ContainerDataDirKey] != ""</span>
                },
                "GetDataDir": func() string <span class="cov8" title="1">{
                        if profile != nil &amp;&amp; profile.KubernetesConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntimeConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntimeConfig[datamodel.ContainerDataDirKey] != "" </span><span class="cov8" title="1">{
                                return profile.KubernetesConfig.ContainerRuntimeConfig[datamodel.ContainerDataDirKey]
                        }</span>
                        <span class="cov8" title="1">if profile.KubeletDiskType == datamodel.TempDisk </span><span class="cov8" title="1">{
                                return datamodel.TempDiskContainerDataDir
                        }</span>
                        <span class="cov8" title="1">return cs.Properties.OrchestratorProfile.KubernetesConfig.ContainerRuntimeConfig[datamodel.ContainerDataDirKey]</span>
                },
                "HasKubeletDiskType": func() bool <span class="cov8" title="1">{
                        return profile != nil &amp;&amp; profile.KubeletDiskType != "" &amp;&amp; profile.KubeletDiskType != datamodel.OSDisk
                }</span>,
                "GetKubeletDiskType": func() string <span class="cov0" title="0">{
                        if profile != nil &amp;&amp; profile.KubeletDiskType != "" &amp;&amp; profile.KubeletDiskType != datamodel.OSDisk </span><span class="cov0" title="0">{
                                return string(profile.KubeletDiskType)
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                },
                "IsKrustlet": func() bool <span class="cov8" title="1">{
                        return strings.EqualFold(string(profile.WorkloadRuntime), string(datamodel.WasmWasi))
                }</span>,
                "GetBase64CertificateAuthorityData": func() string <span class="cov0" title="0">{
                        if cs != nil &amp;&amp; cs.Properties != nil &amp;&amp; cs.Properties.CertificateProfile != nil &amp;&amp; cs.Properties.CertificateProfile.CaCertificate != "" </span><span class="cov0" title="0">{
                                data := cs.Properties.CertificateProfile.CaCertificate
                                return base64.StdEncoding.EncodeToString([]byte(data))
                        }</span>
                        <span class="cov0" title="0">return ""</span>
                },
                "GetKubenetTemplate": func() string <span class="cov8" title="1">{
                        return base64.StdEncoding.EncodeToString([]byte(kubenetCniTemplate))
                }</span>,
                "GetContainerdConfigContent": func() string <span class="cov8" title="1">{
                        parameters := getParameters(config, "baker", "1.0")
                        // get variable cloudInit
                        variables := getCustomDataVariables(config)
                        containerdConfigTemplate := template.Must(template.New("kubenet").Funcs(getBakerFuncMap(config, parameters, variables)).Parse(containerdConfigTemplateString))
                        var b bytes.Buffer
                        if err := containerdConfigTemplate.Execute(&amp;b, profile); err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Errorf("failed to execute sysctl template: %s", err))</span>
                        }
                        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString(b.Bytes())</span>
                },
                "TeleportEnabled": func() bool <span class="cov8" title="1">{
                        return config.EnableACRTeleportPlugin
                }</span>,
                "HasDCSeriesSKU": func() bool <span class="cov0" title="0">{
                        return cs.Properties.HasDCSeriesSKU()
                }</span>,
                "GetHyperkubeImageReference": func() string <span class="cov8" title="1">{
                        return config.K8sComponents.HyperkubeImageURL
                }</span>,
                "GetTargetEnvironment": func() string <span class="cov8" title="1">{
                        if cs.IsAKSCustomCloud() </span><span class="cov8" title="1">{
                                return cs.Properties.CustomCloudEnv.Name
                        }</span>
                        <span class="cov8" title="1">return GetCloudTargetEnv(cs.Location)</span>
                },
                "IsAKSCustomCloud": func() bool <span class="cov8" title="1">{
                        return cs.IsAKSCustomCloud()
                }</span>,
                "GetInitAKSCustomCloudFilepath": func() string <span class="cov8" title="1">{
                        return initAKSCustomCloudFilepath
                }</span>,
                "AKSCustomCloudRepoDepotEndpoint": func() string <span class="cov8" title="1">{
                        return cs.Properties.CustomCloudEnv.RepoDepotEndpoint
                }</span>,
                "AKSCustomCloudManagementPortalURL": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ManagementPortalURL
                }</span>,
                "AKSCustomCloudPublishSettingsURL": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.PublishSettingsURL
                }</span>,
                "AKSCustomCloudServiceManagementEndpoint": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ServiceManagementEndpoint
                }</span>,
                "AKSCustomCloudResourceManagerEndpoint": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ResourceManagerEndpoint
                }</span>,
                "AKSCustomCloudActiveDirectoryEndpoint": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ActiveDirectoryEndpoint
                }</span>,
                "AKSCustomCloudGalleryEndpoint": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.GalleryEndpoint
                }</span>,
                "AKSCustomCloudKeyVaultEndpoint": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.KeyVaultEndpoint
                }</span>,
                "AKSCustomCloudGraphEndpoint": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.GraphEndpoint
                }</span>,
                "AKSCustomCloudServiceBusEndpoint": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ServiceBusEndpoint
                }</span>,
                "AKSCustomCloudBatchManagementEndpoint": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.BatchManagementEndpoint
                }</span>,
                "AKSCustomCloudStorageEndpointSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.StorageEndpointSuffix
                }</span>,
                "AKSCustomCloudSqlDatabaseDNSSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.SQLDatabaseDNSSuffix
                }</span>,
                "AKSCustomCloudTrafficManagerDNSSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.TrafficManagerDNSSuffix
                }</span>,
                "AKSCustomCloudKeyVaultDNSSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.KeyVaultDNSSuffix
                }</span>,
                "AKSCustomCloudServiceBusEndpointSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ServiceBusEndpointSuffix
                }</span>,
                "AKSCustomCloudServiceManagementVMDNSSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ServiceManagementVMDNSSuffix
                }</span>,
                "AKSCustomCloudResourceManagerVMDNSSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ResourceManagerVMDNSSuffix
                }</span>,
                "AKSCustomCloudContainerRegistryDNSSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ContainerRegistryDNSSuffix
                }</span>,
                "AKSCustomCloudCosmosDBDNSSuffix": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.CosmosDBDNSSuffix
                }</span>,
                "AKSCustomCloudTokenAudience": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.TokenAudience
                }</span>,
                "AKSCustomCloudResourceIdentifiersGraph": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ResourceIdentifiers.Graph
                }</span>,
                "AKSCustomCloudResourceIdentifiersKeyVault": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ResourceIdentifiers.KeyVault
                }</span>,
                "AKSCustomCloudResourceIdentifiersDatalake": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ResourceIdentifiers.Datalake
                }</span>,
                "AKSCustomCloudResourceIdentifiersBatch": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ResourceIdentifiers.Batch
                }</span>,
                "AKSCustomCloudResourceIdentifiersOperationalInsights": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ResourceIdentifiers.OperationalInsights
                }</span>,
                "AKSCustomCloudResourceIdentifiersStorage": func() string <span class="cov0" title="0">{
                        return cs.Properties.CustomCloudEnv.ResourceIdentifiers.Storage
                }</span>,
                "GetCSEHelpersScriptFilepath": func() string <span class="cov8" title="1">{
                        return cseHelpersScriptFilepath
                }</span>,
                "GetCSEHelpersScriptDistroFilepath": func() string <span class="cov8" title="1">{
                        return cseHelpersScriptDistroFilepath
                }</span>,
                "GetCSEInstallScriptFilepath": func() string <span class="cov8" title="1">{
                        return cseInstallScriptFilepath
                }</span>,
                "GetCSEInstallScriptDistroFilepath": func() string <span class="cov8" title="1">{
                        return cseInstallScriptDistroFilepath
                }</span>,
                "GetCSEConfigScriptFilepath": func() string <span class="cov8" title="1">{
                        return cseConfigScriptFilepath
                }</span>,
                "GetCustomSearchDomainsCSEScriptFilepath": func() string <span class="cov8" title="1">{
                        return customSearchDomainsCSEScriptFilepath
                }</span>,
                "GetDHCPv6ServiceCSEScriptFilepath": func() string <span class="cov8" title="1">{
                        return dhcpV6ServiceCSEScriptFilepath
                }</span>,
                "GetDHCPv6ConfigCSEScriptFilepath": func() string <span class="cov8" title="1">{
                        return dhcpV6ConfigCSEScriptFilepath
                }</span>,
                "HasPrivateAzureRegistryServer": func() bool <span class="cov8" title="1">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.PrivateAzureRegistryServer != ""
                }</span>,
                "GetPrivateAzureRegistryServer": func() string <span class="cov8" title="1">{
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.PrivateAzureRegistryServer
                }</span>,
                "OpenBraces": func() string <span class="cov8" title="1">{
                        return "{{"
                }</span>,
                "CloseBraces": func() string <span class="cov8" title="1">{
                        return "}}"
                }</span>,
                "BoolPtrToInt": func(p *bool) int <span class="cov8" title="1">{
                        if p == nil </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                        <span class="cov8" title="1">if v := *p; v </span><span class="cov8" title="1">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
                "UserAssignedIDEnabled": func() bool <span class="cov8" title="1">{
                        // TODO(qinhao): we need to move this to NodeBootstrappingConfiguration as cs.Properties
                        //               is to be moved away from NodeBootstrappingConfiguration
                        return cs.Properties.OrchestratorProfile.KubernetesConfig.UserAssignedIDEnabled()
                }</span>,
                // HTTP proxy related funcs
                "ShouldConfigureHTTPProxy": func() bool <span class="cov8" title="1">{
                        return config.HTTPProxyConfig != nil &amp;&amp; (config.HTTPProxyConfig.HTTPProxy != nil || config.HTTPProxyConfig.HTTPSProxy != nil)
                }</span>,
                "HasHTTPProxy": func() bool <span class="cov0" title="0">{
                        return config.HTTPProxyConfig != nil &amp;&amp; config.HTTPProxyConfig.HTTPProxy != nil
                }</span>,
                "HasHTTPSProxy": func() bool <span class="cov0" title="0">{
                        return config.HTTPProxyConfig != nil &amp;&amp; config.HTTPProxyConfig.HTTPSProxy != nil
                }</span>,
                "HasNoProxy": func() bool <span class="cov0" title="0">{
                        return config.HTTPProxyConfig != nil &amp;&amp; config.HTTPProxyConfig.NoProxy != nil
                }</span>,
                "GetHTTPProxy": func() string <span class="cov8" title="1">{
                        if config.HTTPProxyConfig != nil &amp;&amp; config.HTTPProxyConfig.HTTPProxy != nil </span><span class="cov8" title="1">{
                                return *config.HTTPProxyConfig.HTTPProxy
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "GetHTTPSProxy": func() string <span class="cov8" title="1">{
                        if config.HTTPProxyConfig != nil &amp;&amp; config.HTTPProxyConfig.HTTPSProxy != nil </span><span class="cov8" title="1">{
                                return *config.HTTPProxyConfig.HTTPSProxy
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "GetNoProxy": func() string <span class="cov8" title="1">{
                        if config.HTTPProxyConfig != nil &amp;&amp; config.HTTPProxyConfig.NoProxy != nil </span><span class="cov8" title="1">{
                                return strings.Join(*config.HTTPProxyConfig.NoProxy, ",")
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "ShouldConfigureHTTPProxyCA": func() bool <span class="cov8" title="1">{
                        return config.HTTPProxyConfig != nil &amp;&amp; config.HTTPProxyConfig.TrustedCA != nil
                }</span>,
                "GetHTTPProxyCA": func() string <span class="cov8" title="1">{
                        if config.HTTPProxyConfig != nil &amp;&amp; config.HTTPProxyConfig.TrustedCA != nil </span><span class="cov8" title="1">{
                                return *config.HTTPProxyConfig.TrustedCA
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                },
                "FIPSEnabled": func() bool <span class="cov8" title="1">{
                        return config.FIPSEnabled
                }</span>,
                "GetMessageOfTheDay": func() string <span class="cov8" title="1">{
                        return profile.MessageOfTheDay
                }</span>,
                "GetProxyVariables": func() string <span class="cov8" title="1">{
                        return getProxyVariables(config)
                }</span>,
                "GetOutboundCommand": func() string <span class="cov8" title="1">{
                        return getOutBoundCmd(config, config.CloudSpecConfig)
                }</span>,
                "GPUNeedsFabricManager": func() bool <span class="cov8" title="1">{
                        return gpuNeedsFabricManager(profile.VMSize)
                }</span>,
                "GPUDriverVersion": func() string <span class="cov8" title="1">{
                        return getGPUDriverVersion(profile.VMSize)
                }</span>,
                "GetHnsRemediatorIntervalInMinutes": func() uint32 <span class="cov8" title="1">{
                        if cs.Properties.WindowsProfile != nil </span><span class="cov8" title="1">{
                                return cs.Properties.WindowsProfile.GetHnsRemediatorIntervalInMinutes()
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
                "ShouldConfigureCustomCATrust": func() bool <span class="cov8" title="1">{
                        return areCustomCATrustCertsPopulated(*config)
                }</span>,
                "GetCustomCATrustConfigCerts": func() []string <span class="cov8" title="1">{
                        if areCustomCATrustCertsPopulated(*config) </span><span class="cov8" title="1">{
                                return config.CustomCATrustConfig.CustomCATrustCerts
                        }</span>
                        <span class="cov8" title="1">return []string{}</span>
                },
                "GetLogGeneratorIntervalInMinutes": func() uint32 <span class="cov8" title="1">{
                        if cs.Properties.WindowsProfile != nil </span><span class="cov8" title="1">{
                                return cs.Properties.WindowsProfile.GetLogGeneratorIntervalInMinutes()
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
                "ShouldDisableSSH": func() bool <span class="cov8" title="1">{
                        return config.SSHStatus == datamodel.SSHOff
                }</span>,
        }
}

// NV series GPUs target graphics workloads vs NC which targets compute
// they typically use GRID, not CUDA drivers, and will fail to install CUDA drivers.
// NVv1 seems to run with CUDA, NVv5 requires GRID.
// NVv3 is untested on AKS, NVv4 is AMD so n/a, and NVv2 no longer seems to exist (?)
func getGPUDriverVersion(size string) string <span class="cov8" title="1">{
        if useGridDrivers(size) </span><span class="cov8" title="1">{
                return datamodel.Nvidia510GridDriverVersion
        }</span>
        <span class="cov8" title="1">if isStandardNCv1(size) </span><span class="cov8" title="1">{
                return datamodel.Nvidia470CudaDriverVersion
        }</span>
        <span class="cov8" title="1">return datamodel.Nvidia525CudaDriverVersion</span>
}

func isStandardNCv1(size string) bool <span class="cov8" title="1">{
        tmp := strings.ToLower(size)
        return strings.HasPrefix(tmp, "standard_nc") &amp;&amp; !strings.Contains(tmp, "_v")
}</span>

func useGridDrivers(size string) bool <span class="cov8" title="1">{
        return datamodel.ConvergedGPUDriverSizes[strings.ToLower(size)]
}</span>

func gpuNeedsFabricManager(size string) bool <span class="cov8" title="1">{
        return datamodel.FabricManagerGPUSizes[strings.ToLower(size)]
}</span>

func areCustomCATrustCertsPopulated(config datamodel.NodeBootstrappingConfiguration) bool <span class="cov8" title="1">{
        return config.CustomCATrustConfig != nil &amp;&amp; len(config.CustomCATrustConfig.CustomCATrustCerts) &gt; 0
}</span>

func isMariner(osSku string) bool <span class="cov8" title="1">{
        return osSku == datamodel.OSSKUCBLMariner || osSku == datamodel.OSSKUMariner
}</span>

const kubenetCniTemplate = `
{
    "cniVersion": "0.3.1",
    "name": "kubenet",
    "plugins": [{
    "type": "bridge",
    "bridge": "cbr0",
    "mtu": 1500,
    "addIf": "eth0",
    "isGateway": true,
    "ipMasq": false,
    "promiscMode": true,
    "hairpinMode": false,
    "ipam": {
        "type": "host-local",
        "ranges": [{{range $i, $range := .PodCIDRRanges}}{{if $i}}, {{end}}[{"subnet": "{{$range}}"}]{{end}}],
        "routes": [{{range $i, $route := .Routes}}{{if $i}}, {{end}}{"dst": "{{$route}}"}{{end}}]
    }
    },
    {
    "type": "portmap",
    "capabilities": {"portMappings": true},
    "externalSetMarkChain": "KUBE-MARK-MASQ"
    }]
}
`

const containerdConfigTemplateString = `version = 2
oom_score = 0{{if HasDataDir }}
root = "{{GetDataDir}}"{{- end}}
[plugins."io.containerd.grpc.v1.cri"]
        sandbox_image = "{{GetPodInfraContainerSpec}}"
        [plugins."io.containerd.grpc.v1.cri".containerd]
                {{- if TeleportEnabled }}
                snapshotter = "teleportd"
                disable_snapshot_annotations = false
                {{- end}}
                {{- if IsNSeriesSKU }}
                default_runtime_name = "nvidia-container-runtime"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.nvidia-container-runtime]
                        runtime_type = "io.containerd.runc.v2"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.nvidia-container-runtime.options]
                        BinaryName = "/usr/bin/nvidia-container-runtime"
                        {{- if Is2204VHD }}
                        SystemdCgroup = true
                        {{- end}}
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.untrusted]
                        runtime_type = "io.containerd.runc.v2"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.untrusted.options]
                        BinaryName = "/usr/bin/nvidia-container-runtime"
                {{- else}}
                default_runtime_name = "runc"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
                        runtime_type = "io.containerd.runc.v2"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
                        BinaryName = "/usr/bin/runc"
                        {{- if Is2204VHD }}
                        SystemdCgroup = true
                        {{- end}}
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.untrusted]
                        runtime_type = "io.containerd.runc.v2"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.untrusted.options]
                        BinaryName = "/usr/bin/runc"
                {{- end}}
                {{- if IsKata }}
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.kata]
                        runtime_type = "io.containerd.kata.v2"
                {{- end}}
                {{- if IsKrustlet }}
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.spin]
                        runtime_type = "io.containerd.spin.v1"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.slight]
                        runtime_type = "io.containerd.slight.v1"
                {{- end}}
        {{- if and (IsKubenet) (not HasCalicoNetworkPolicy) }}
        [plugins."io.containerd.grpc.v1.cri".cni]
                bin_dir = "/opt/cni/bin"
                conf_dir = "/etc/cni/net.d"
                conf_template = "/etc/containerd/kubenet_template.conf"
        {{- end}}
        {{- if IsKubernetesVersionGe "1.22.0"}}
        [plugins."io.containerd.grpc.v1.cri".registry]
                config_path = "/etc/containerd/certs.d"
        {{- end}}
        [plugins."io.containerd.grpc.v1.cri".registry.headers]
                X-Meta-Source-Client = ["azure/aks"]
[metrics]
        address = "0.0.0.0:10257"
{{- if TeleportEnabled }}
[proxy_plugins]
        [proxy_plugins.teleportd]
                type = "snapshot"
                address = "/run/teleportd/snapshotter.sock"
{{- end}}
`
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package agent

import (
        "context"
        "fmt"

        "github.com/Azure/agentbaker/pkg/agent/datamodel"
)

type AgentBaker interface {
        GetNodeBootstrapping(ctx context.Context, config *datamodel.NodeBootstrappingConfiguration) (*datamodel.NodeBootstrapping, error)
        GetLatestSigImageConfig(sigConfig datamodel.SIGConfig, region string, distro datamodel.Distro) (*datamodel.SigImageConfig, error)
        GetDistroSigImageConfig(sigConfig datamodel.SIGConfig, region string) (map[datamodel.Distro]datamodel.SigImageConfig, error)
}

func NewAgentBaker() (AgentBaker, error) <span class="cov8" title="1">{
        return &amp;agentBakerImpl{}, nil
}</span>

type agentBakerImpl struct{}

func (agentBaker *agentBakerImpl) GetNodeBootstrapping(ctx context.Context,
        config *datamodel.NodeBootstrappingConfiguration) (*datamodel.NodeBootstrapping, error) <span class="cov8" title="1">{
        templateGenerator := InitializeTemplateGenerator()
        nodeBootstrapping := &amp;datamodel.NodeBootstrapping{
                CustomData: templateGenerator.GetNodeBootstrappingPayload(config),
                CSE:        templateGenerator.GetNodeBootstrappingCmd(config),
        }

        distro := config.AgentPoolProfile.Distro
        if distro == datamodel.CustomizedWindowsOSImage || distro == datamodel.CustomizedImage </span><span class="cov8" title="1">{
                return nodeBootstrapping, nil
        }</span>

        <span class="cov8" title="1">osImageConfigMap, hasCloud := datamodel.AzureCloudToOSImageMap[config.CloudSpecConfig.CloudName]
        if !hasCloud </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("don't have settings for cloud %s", config.CloudSpecConfig.CloudName)
        }</span>

        <span class="cov8" title="1">if osImageConfig, hasImage := osImageConfigMap[distro]; hasImage </span><span class="cov8" title="1">{
                nodeBootstrapping.OSImageConfig = &amp;osImageConfig
        }</span>

        <span class="cov8" title="1">sigAzureEnvironmentSpecConfig, err := datamodel.GetSIGAzureCloudSpecConfig(config.SIGConfig, config.ContainerService.Location)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">nodeBootstrapping.SigImageConfig = findSIGImageConfig(sigAzureEnvironmentSpecConfig, distro)
        if nodeBootstrapping.SigImageConfig == nil &amp;&amp; nodeBootstrapping.OSImageConfig == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("can't find image for distro %s", distro)
        }</span>

        <span class="cov8" title="1">return nodeBootstrapping, nil</span>
}

func findSIGImageConfig(sigConfig datamodel.SIGAzureEnvironmentSpecConfig, distro datamodel.Distro) *datamodel.SigImageConfig <span class="cov8" title="1">{
        if imageConfig, ok := sigConfig.SigUbuntuImageConfig[distro]; ok </span><span class="cov8" title="1">{
                return &amp;imageConfig
        }</span>
        <span class="cov8" title="1">if imageConfig, ok := sigConfig.SigCBLMarinerImageConfig[distro]; ok </span><span class="cov0" title="0">{
                return &amp;imageConfig
        }</span>
        <span class="cov8" title="1">if imageConfig, ok := sigConfig.SigWindowsImageConfig[distro]; ok </span><span class="cov0" title="0">{
                return &amp;imageConfig
        }</span>
        <span class="cov8" title="1">if imageConfig, ok := sigConfig.SigUbuntuEdgeZoneImageConfig[distro]; ok </span><span class="cov0" title="0">{
                return &amp;imageConfig
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (agentBaker *agentBakerImpl) GetLatestSigImageConfig(
        sigConfig datamodel.SIGConfig, region string, distro datamodel.Distro) (*datamodel.SigImageConfig, error) <span class="cov8" title="1">{
        sigAzureEnvironmentSpecConfig, err := datamodel.GetSIGAzureCloudSpecConfig(sigConfig, region)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sigImageConfig := findSIGImageConfig(sigAzureEnvironmentSpecConfig, distro)
        if sigImageConfig == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("can't find SIG image config for distro %s in region %s", distro, region)
        }</span>
        <span class="cov8" title="1">return sigImageConfig, nil</span>
}

func (agentBaker *agentBakerImpl) GetDistroSigImageConfig(sigConfig datamodel.SIGConfig, region string) (map[datamodel.Distro]datamodel.SigImageConfig, error) <span class="cov0" title="0">{
        allAzureSigConfig, err := datamodel.GetSIGAzureCloudSpecConfig(sigConfig, region)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get sig image config: %v", err)
        }</span>

        <span class="cov0" title="0">allDistros := map[datamodel.Distro]datamodel.SigImageConfig{}
        for distro, sigConfig := range allAzureSigConfig.SigWindowsImageConfig </span><span class="cov0" title="0">{
                allDistros[distro] = sigConfig
        }</span>

        <span class="cov0" title="0">for distro, sigConfig := range allAzureSigConfig.SigCBLMarinerImageConfig </span><span class="cov0" title="0">{
                allDistros[distro] = sigConfig
        }</span>

        <span class="cov0" title="0">for distro, sigConfig := range allAzureSigConfig.SigUbuntuImageConfig </span><span class="cov0" title="0">{
                allDistros[distro] = sigConfig
        }</span>

        <span class="cov0" title="0">for distro, sigConfig := range allAzureSigConfig.SigUbuntuEdgeZoneImageConfig </span><span class="cov0" title="0">{
                allDistros[distro] = sigConfig
        }</span>

        <span class="cov0" title="0">return allDistros, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package datamodel

import (
        "bufio"
        "bytes"
        "fmt"
        "regexp"
        "sort"
        "strings"

        "github.com/pkg/errors"
)

// ValidateDNSPrefix is a helper function to check that a DNS Prefix is valid
func ValidateDNSPrefix(dnsName string) error <span class="cov8" title="1">{
        dnsNameRegex := `^([A-Za-z][A-Za-z0-9-]{1,43}[A-Za-z0-9])$`
        re, err := regexp.Compile(dnsNameRegex)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !re.MatchString(dnsName) </span><span class="cov8" title="1">{
                return errors.Errorf("DNSPrefix '%s' is invalid. The DNSPrefix must contain between 3 and 45 characters and can contain only letters, numbers, and hyphens.  It must start with a letter and must end with a letter or a number. (length was %d)", dnsName, len(dnsName))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsSgxEnabledSKU determines if an VM SKU has SGX driver support
func IsSgxEnabledSKU(vmSize string) bool <span class="cov8" title="1">{
        switch vmSize </span>{
        case "Standard_DC2s", "Standard_DC4s":<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsMIGNode check if the node should be partitioned
func IsMIGNode(GPUInstanceProfile string) bool <span class="cov0" title="0">{
        return GPUInstanceProfile != ""
}</span>

// GetStorageAccountType returns the support managed disk storage tier for a give VM size
func GetStorageAccountType(sizeName string) (string, error) <span class="cov8" title="1">{
        spl := strings.Split(sizeName, "_")
        if len(spl) &lt; 2 </span><span class="cov8" title="1">{
                return "", errors.Errorf("Invalid sizeName: %s", sizeName)
        }</span>
        <span class="cov8" title="1">capability := spl[1]
        if strings.Contains(strings.ToLower(capability), "s") </span><span class="cov8" title="1">{
                return "Premium_LRS", nil
        }</span>
        <span class="cov8" title="1">return "Standard_LRS", nil</span>
}

// GetOrderedEscapedKeyValsString returns an ordered string of escaped, quoted key=val
func GetOrderedEscapedKeyValsString(config map[string]string) string <span class="cov8" title="1">{
        keys := []string{}
        for key := range config </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        var buf bytes.Buffer
        for _, key := range keys </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("\"%s=%s\", ", key, config[key]))
        }</span>
        <span class="cov8" title="1">return strings.TrimSuffix(buf.String(), ", ")</span>
}

// SliceIntIsNonEmpty is a simple convenience to determine if a []int is non-empty
func SliceIntIsNonEmpty(s []int) bool <span class="cov8" title="1">{
        return len(s) &gt; 0
}</span>

// WrapAsVerbatim formats a string for inserting a literal string into an ARM expression
func WrapAsVerbatim(s string) string <span class="cov8" title="1">{
        return fmt.Sprintf("',%s,'", s)
}</span>

// IndentString pads each line of an original string with N spaces and returns the new value.
func IndentString(original string, spaces int) string <span class="cov8" title="1">{
        out := bytes.NewBuffer(nil)
        scanner := bufio.NewScanner(strings.NewReader(original))
        for scanner.Scan() </span><span class="cov8" title="1">{
                for i := 0; i &lt; spaces; i++ </span><span class="cov8" title="1">{
                        out.WriteString(" ")
                }</span>
                <span class="cov8" title="1">out.WriteString(scanner.Text())
                out.WriteString("\n")</span>
        }
        <span class="cov8" title="1">return out.String()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package datamodel

import (
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/google/uuid"
)

// CreateMockContainerService returns a mock container service for testing purposes
func CreateMockContainerService(containerServiceName, orchestratorVersion string, masterCount, agentCount int, certs bool) *ContainerService <span class="cov0" title="0">{
        cs := ContainerService{}
        cs.ID = uuid.Must(uuid.NewRandom()).String()
        cs.Location = "eastus"
        cs.Name = containerServiceName

        cs.Properties = &amp;Properties{}

        cs.Properties.AgentPoolProfiles = []*AgentPoolProfile{}
        agentPool := &amp;AgentPoolProfile{}
        agentPool.Name = "agentpool1"
        agentPool.VMSize = "Standard_D2_v2"
        agentPool.AvailabilityProfile = "AvailabilitySet"
        agentPool.StorageProfile = "StorageAccount"

        cs.Properties.AgentPoolProfiles = append(cs.Properties.AgentPoolProfiles, agentPool)

        cs.Properties.LinuxProfile = &amp;LinuxProfile{
                AdminUsername: "azureuser",
                SSH: struct {
                        PublicKeys []PublicKey `json:"publicKeys"`
                }{},
        }

        cs.Properties.LinuxProfile.AdminUsername = "azureuser"
        cs.Properties.LinuxProfile.SSH.PublicKeys = append(
                cs.Properties.LinuxProfile.SSH.PublicKeys, PublicKey{KeyData: "test"})

        cs.Properties.ServicePrincipalProfile = &amp;ServicePrincipalProfile{}
        cs.Properties.ServicePrincipalProfile.ClientID = "DEC923E3-1EF1-4745-9516-37906D56DEC4"
        cs.Properties.ServicePrincipalProfile.Secret = "DEC923E3-1EF1-4745-9516-37906D56DEC4"

        cs.Properties.OrchestratorProfile = &amp;OrchestratorProfile{}
        cs.Properties.OrchestratorProfile.OrchestratorType = Kubernetes
        cs.Properties.OrchestratorProfile.OrchestratorVersion = orchestratorVersion
        cs.Properties.OrchestratorProfile.KubernetesConfig = &amp;KubernetesConfig{
                EnableSecureKubelet:     to.BoolPtr(true),
                EnableRbac:              to.BoolPtr(true),
                DockerBridgeSubnet:      "172.17.0.1/16",
                GCLowThreshold:          80,
                GCHighThreshold:         85,
                MaxPods:                 30,
                ClusterSubnet:           "10.240.0.0/12",
                ContainerRuntime:        Docker,
                NetworkPlugin:           "kubenet",
                LoadBalancerSku:         "Basic",
                ControllerManagerConfig: make(map[string]string),
        }

        cs.Properties.CertificateProfile = &amp;CertificateProfile{}
        if certs </span><span class="cov0" title="0">{
                cs.Properties.CertificateProfile.CaCertificate = "cacert"
                cs.Properties.CertificateProfile.KubeConfigCertificate = "kubeconfigcert"
                cs.Properties.CertificateProfile.KubeConfigPrivateKey = "kubeconfigkey"
                cs.Properties.CertificateProfile.APIServerCertificate = "apiservercert"
                cs.Properties.CertificateProfile.ClientCertificate = "clientcert"
                cs.Properties.CertificateProfile.ClientPrivateKey = "clientkey"

        }</span>

        <span class="cov0" title="0">return &amp;cs</span>
}

// GetK8sDefaultProperties returns a struct of type Properties for testing purposes.
func GetK8sDefaultProperties(hasWindows bool) *Properties <span class="cov0" title="0">{
        p := &amp;Properties{
                OrchestratorProfile: &amp;OrchestratorProfile{
                        OrchestratorType: Kubernetes,
                        KubernetesConfig: &amp;KubernetesConfig{},
                },
                HostedMasterProfile: &amp;HostedMasterProfile{
                        DNSPrefix: "foo",
                },
                AgentPoolProfiles: []*AgentPoolProfile{
                        {
                                Name:                "agentpool",
                                VMSize:              "Standard_D2_v2",
                                AvailabilityProfile: AvailabilitySet,
                        },
                },
                ServicePrincipalProfile: &amp;ServicePrincipalProfile{
                        ClientID: "clientID",
                        Secret:   "clientSecret",
                },
        }

        if hasWindows </span><span class="cov0" title="0">{
                p.AgentPoolProfiles = []*AgentPoolProfile{
                        {
                                Name:                "agentpool",
                                VMSize:              "Standard_D2_v2",
                                AvailabilityProfile: AvailabilitySet,
                                OSType:              Windows,
                        },
                }
                p.WindowsProfile = &amp;WindowsProfile{
                        AdminUsername: "azureuser",
                        AdminPassword: "replacepassword1234$",
                }
        }</span>

        <span class="cov0" title="0">return p</span>
}

func getMockProperitesWithCustomClouEnv() Properties <span class="cov8" title="1">{
        properties := Properties{
                CustomCloudEnv: &amp;CustomCloudEnv{
                        Name:                         "akscustom",
                        McrURL:                       "mcr.microsoft.fakecustomcloud",
                        RepoDepotEndpoint:            "https://repodepot.azure.microsoft.fakecustomcloud/ubuntu",
                        ManagementPortalURL:          "https://portal.azure.microsoft.fakecustomcloud/",
                        PublishSettingsURL:           "",
                        ServiceManagementEndpoint:    "https://management.core.microsoft.fakecustomcloud/",
                        ResourceManagerEndpoint:      "https://management.azure.microsoft.fakecustomcloud/",
                        ActiveDirectoryEndpoint:      "https://login.microsoftonline.microsoft.fakecustomcloud/",
                        GalleryEndpoint:              "",
                        KeyVaultEndpoint:             "https://vault.cloudapi.microsoft.fakecustomcloud/",
                        GraphEndpoint:                "https://graph.cloudapi.microsoft.fakecustomcloud/",
                        ServiceBusEndpoint:           "",
                        BatchManagementEndpoint:      "",
                        StorageEndpointSuffix:        "core.microsoft.fakecustomcloud",
                        SQLDatabaseDNSSuffix:         "database.cloudapi.microsoft.fakecustomcloud",
                        TrafficManagerDNSSuffix:      "",
                        KeyVaultDNSSuffix:            "vault.cloudapi.microsoft.fakecustomcloud",
                        ServiceBusEndpointSuffix:     "",
                        ServiceManagementVMDNSSuffix: "",
                        ResourceManagerVMDNSSuffix:   "cloudapp.azure.microsoft.fakecustomcloud/",
                        ContainerRegistryDNSSuffix:   ".azurecr.microsoft.fakecustomcloud",
                        CosmosDBDNSSuffix:            "documents.core.microsoft.fakecustomcloud/",
                        TokenAudience:                "https://management.core.microsoft.fakecustomcloud/",
                        ResourceIdentifiers: ResourceIdentifiers{
                                Graph:               "",
                                KeyVault:            "",
                                Datalake:            "",
                                Batch:               "",
                                OperationalInsights: "",
                                Storage:             "",
                        },
                },
        }
        return properties
}</span>

func getMockAddon(name string) KubernetesAddon <span class="cov8" title="1">{
        return KubernetesAddon{
                Name: name,
                Containers: []KubernetesContainerSpec{
                        {
                                Name:           name,
                                CPURequests:    "50m",
                                MemoryRequests: "150Mi",
                                CPULimits:      "50m",
                                MemoryLimits:   "150Mi",
                        },
                },
                Pools: []AddonNodePoolsConfig{
                        {
                                Name: "pool1",
                                Config: map[string]string{
                                        "min-nodes": "3",
                                        "max-nodes": "3",
                                },
                        },
                },
        }
}</span>

var (
        AzurePublicCloudSpecForTest = &amp;AzureEnvironmentSpecConfig{
                CloudName: "AzurePublicCloud",
                //DockerSpecConfig specify the docker engine download repo
                DockerSpecConfig: DockerSpecConfig{
                        DockerEngineRepo:         "https://aptdocker.azureedge.net/repo",
                        DockerComposeDownloadURL: "https://github.com/docker/compose/releases/download",
                },
                //KubernetesSpecConfig is the default kubernetes container image url.
                KubernetesSpecConfig: KubernetesSpecConfig{
                        KubernetesImageBase:    "k8s.gcr.io/",
                        TillerImageBase:        "gcr.io/kubernetes-helm/",
                        ACIConnectorImageBase:  "microsoft/",
                        NVIDIAImageBase:        "nvidia/",
                        CalicoImageBase:        "calico/",
                        AzureCNIImageBase:      "mcr.microsoft.com/containernetworking/",
                        MCRKubernetesImageBase: "mcr.microsoft.com/",

                        KubeBinariesSASURLBase:               "https://acs-mirror.azureedge.net/kubernetes/",
                        WindowsTelemetryGUID:                 "fb801154-36b9-41bc-89c2-f4d4f05472b0",
                        CNIPluginsDownloadURL:                "https://acs-mirror.azureedge.net/cni/cni-plugins-amd64-v0.7.6.tgz",
                        VnetCNILinuxPluginsDownloadURL:       "https://acs-mirror.azureedge.net/azure-cni/v1.1.3/binaries/azure-vnet-cni-linux-amd64-v1.1.3.tgz",
                        VnetCNIWindowsPluginsDownloadURL:     "https://acs-mirror.azureedge.net/azure-cni/v1.1.3/binaries/azure-vnet-cni-singletenancy-windows-amd64-v1.1.3.zip",
                        ContainerdDownloadURLBase:            "https://storage.googleapis.com/cri-containerd-release/",
                        CSIProxyDownloadURL:                  "https://acs-mirror.azureedge.net/csi-proxy/v0.1.0/binaries/csi-proxy.tar.gz",
                        WindowsProvisioningScriptsPackageURL: "https://acs-mirror.azureedge.net/aks-engine/windows/provisioning/signedscripts-v0.2.2.zip",
                        WindowsPauseImageURL:                 "mcr.microsoft.com/oss/kubernetes/pause:1.4.0",
                        AlwaysPullWindowsPauseImage:          false,
                        CseScriptsPackageURL:                 "https://acs-mirror.azureedge.net/aks/windows/cse/csescripts-v0.0.1.zip",
                        CNIARM64PluginsDownloadURL:           "https://acs-mirror.azureedge.net/cni-plugins/v0.8.7/binaries/cni-plugins-linux-arm64-v0.8.7.tgz",
                        VnetCNIARM64LinuxPluginsDownloadURL:  "https://acs-mirror.azureedge.net/azure-cni/v1.4.13/binaries/azure-vnet-cni-linux-arm64-v1.4.14.tgz",
                },

                EndpointConfig: AzureEndpointConfig{
                        ResourceManagerVMDNSSuffix: "cloudapp.azure.com",
                },
        }
)
</pre>
		
		<pre class="file" id="file4" style="display: none">package datamodel

import (
        _ "embed"
        "encoding/json"
        "fmt"
        "strings"
)

const (
        AzurePublicCloudSigTenantID     string = "33e01921-4d64-4f8c-a055-5bdaffd5e33d" // AME Tenant
        AzurePublicCloudSigSubscription string = "109a5e88-712a-48ae-9078-9ca8b3c81345" // AKS VHD
)

// SIGAzureEnvironmentSpecConfig is the overall configuration differences in different cloud environments.
// TODO(tonyxu) merge this with AzureEnvironmentSpecConfig from aks-engine(pkg/api/azenvtypes.go) once it's moved into AKS RP
type SIGAzureEnvironmentSpecConfig struct {
        CloudName                    string                    `json:"cloudName,omitempty"`
        SigTenantID                  string                    `json:"sigTenantID,omitempty"`
        SubscriptionID               string                    `json:"subscriptionID,omitempty"`
        SigUbuntuImageConfig         map[Distro]SigImageConfig `json:"sigUbuntuImageConfig,omitempty"`
        SigCBLMarinerImageConfig     map[Distro]SigImageConfig `json:"sigCBLMarinerImageConfig,omitempty"`
        SigWindowsImageConfig        map[Distro]SigImageConfig `json:"sigWindowsImageConfig,omitempty"`
        SigUbuntuEdgeZoneImageConfig map[Distro]SigImageConfig `json:"sigUbuntuEdgeZoneImageConfig,omitempty"`
        //TODO(adadilli) add PIR constants as well
}

// SIGConfig is used to hold configuration parameters to access AKS VHDs stored in a SIG
type SIGConfig struct {
        TenantID       string                      `json:"tenantID"`
        SubscriptionID string                      `json:"subscriptionID"`
        Galleries      map[string]SIGGalleryConfig `json:"galleries"`
}

type SIGGalleryConfig struct {
        GalleryName   string `json:"galleryName"`
        ResourceGroup string `json:"resourceGroup"`
}

type SigImageConfigOpt func(*SigImageConfig)

func GetCloudTargetEnv(location string) string <span class="cov8" title="1">{
        loc := strings.ToLower(strings.Join(strings.Fields(location), ""))
        switch </span>{
        case strings.HasPrefix(loc, "china"):<span class="cov0" title="0">
                return AzureChinaCloud</span>
        case loc == "germanynortheast" || loc == "germanycentral":<span class="cov0" title="0">
                return AzureGermanCloud</span>
        case strings.HasPrefix(loc, "usgov") || strings.HasPrefix(loc, "usdod"):<span class="cov0" title="0">
                return AzureUSGovernmentCloud</span>
        case strings.HasPrefix(strings.ToLower(loc), "usnat"):<span class="cov0" title="0">
                return USNatCloud</span>
        case strings.HasPrefix(strings.ToLower(loc), "ussec"):<span class="cov0" title="0">
                return USSecCloud</span>
        default:<span class="cov8" title="1">
                return AzurePublicCloud</span>
        }
}

// TODO(amaheshwari): these vars are not consumed by Agentbaker but by RP. do a cleanup to remove these after 20.04 work.
var AvailableUbuntu1804Distros []Distro = []Distro{
        AKSUbuntu1804,
        AKSUbuntu1804Gen2,
        AKSUbuntuGPU1804,
        AKSUbuntuGPU1804Gen2,
        AKSUbuntuContainerd1804,
        AKSUbuntuContainerd1804Gen2,
        AKSUbuntuGPUContainerd1804,
        AKSUbuntuGPUContainerd1804Gen2,
        AKSUbuntuFipsContainerd1804,
        AKSUbuntuFipsContainerd1804Gen2,
        AKSUbuntuFipsGPUContainerd1804,
        AKSUbuntuFipsGPUContainerd1804Gen2,
        AKSUbuntuArm64Containerd1804Gen2,
        AKSUbuntuEdgeZoneContainerd1804,
        AKSUbuntuEdgeZoneContainerd1804Gen2,
}

var AvailableUbuntu2004Distros []Distro = []Distro{
        AKSUbuntuContainerd2004CVMGen2,
        AKSUbuntuFipsContainerd2004,
        AKSUbuntuFipsContainerd2004Gen2,
}

var AvailableUbuntu2204Distros []Distro = []Distro{
        AKSUbuntuContainerd2204,
        AKSUbuntuContainerd2204Gen2,
        AKSUbuntuArm64Containerd2204Gen2,
        AKSUbuntuContainerd2204TLGen2,
}

var AvailableContainerdDistros []Distro = []Distro{
        AKSUbuntuContainerd1804,
        AKSUbuntuContainerd1804Gen2,
        AKSUbuntuGPUContainerd1804,
        AKSUbuntuGPUContainerd1804Gen2,
        AKSUbuntuFipsContainerd1804,
        AKSUbuntuFipsContainerd1804Gen2,
        AKSUbuntuFipsContainerd2004,
        AKSUbuntuFipsContainerd2004Gen2,
        AKSUbuntuFipsGPUContainerd1804,
        AKSUbuntuFipsGPUContainerd1804Gen2,
        AKSUbuntuEdgeZoneContainerd1804,
        AKSUbuntuEdgeZoneContainerd1804Gen2,
        AKSCBLMarinerV1,
        AKSCBLMarinerV2,
        AKSCBLMarinerV2Gen2,
        AKSCBLMarinerV2Gen2Kata,
        AKSCBLMarinerV2Gen2TL,
        AKSCBLMarinerV2KataGen2TL,
        AKSUbuntuArm64Containerd1804Gen2,
        AKSUbuntuArm64Containerd2204Gen2,
        AKSUbuntuContainerd2204,
        AKSUbuntuContainerd2204Gen2,
        AKSUbuntuContainerd2004CVMGen2,
        AKSUbuntuContainerd2204TLGen2,
}

var AvailableGPUDistros []Distro = []Distro{
        AKSUbuntuGPU1804,
        AKSUbuntuGPU1804Gen2,
        AKSUbuntuGPUContainerd1804,
        AKSUbuntuGPUContainerd1804Gen2,
        AKSUbuntuFipsGPUContainerd1804,
        AKSUbuntuFipsGPUContainerd1804Gen2,
}

var AvailableGen2Distros []Distro = []Distro{
        AKSUbuntu1804Gen2,
        AKSUbuntuGPU1804Gen2,
        AKSUbuntuContainerd1804Gen2,
        AKSUbuntuGPUContainerd1804Gen2,
        AKSUbuntuFipsContainerd1804Gen2,
        AKSUbuntuFipsContainerd2004Gen2,
        AKSUbuntuFipsGPUContainerd1804Gen2,
        AKSUbuntuEdgeZoneContainerd1804Gen2,
        AKSUbuntuArm64Containerd1804Gen2,
        AKSUbuntuArm64Containerd2204Gen2,
        AKSUbuntuContainerd2204Gen2,
        AKSUbuntuContainerd2004CVMGen2,
        AKSUbuntuContainerd2204TLGen2,
}

var AvailableCBLMarinerDistros []Distro = []Distro{
        AKSCBLMarinerV1,
        AKSCBLMarinerV2,
        AKSCBLMarinerV2Gen2,
        AKSCBLMarinerV2Gen2Kata,
        AKSCBLMarinerV2Arm64Gen2,
        AKSCBLMarinerV2Gen2TL,
        AKSCBLMarinerV2KataGen2TL,
}

// IsContainerdSKU returns true if distro type is containerd-enabled
func (d Distro) IsContainerdDistro() bool <span class="cov0" title="0">{
        for _, distro := range AvailableContainerdDistros </span><span class="cov0" title="0">{
                if d == distro </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (d Distro) IsGPUDistro() bool <span class="cov0" title="0">{
        for _, distro := range AvailableGPUDistros </span><span class="cov0" title="0">{
                if d == distro </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
func (d Distro) IsGen2Distro() bool <span class="cov0" title="0">{
        for _, distro := range AvailableGen2Distros </span><span class="cov0" title="0">{
                if d == distro </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
func (d Distro) IsCBLMarinerDistro() bool <span class="cov0" title="0">{
        for _, distro := range AvailableCBLMarinerDistros </span><span class="cov0" title="0">{
                if d == distro </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
func (d Distro) IsWindowsSIGDistro() bool <span class="cov0" title="0">{
        for _, distro := range AvailableWindowsSIGDistros </span><span class="cov0" title="0">{
                if d == distro </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (d Distro) IsWindowsPIRDistro() bool <span class="cov0" title="0">{
        for _, distro := range AvailableWindowsPIRDistros </span><span class="cov0" title="0">{
                if d == distro </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// SigImageConfigTemplate represents the SIG image configuration template
type SigImageConfigTemplate struct {
        ResourceGroup string
        Gallery       string
        Definition    string
        Version       string
}

// SigImageConfig represents the SIG image configuration
type SigImageConfig struct {
        SigImageConfigTemplate
        SubscriptionID string
}

// WithOptions converts a SigImageConfigTemplate to SigImageConfig instance via function opts
func (template SigImageConfigTemplate) WithOptions(options ...SigImageConfigOpt) SigImageConfig <span class="cov8" title="1">{
        config := &amp;SigImageConfig{
                SigImageConfigTemplate: template,
        }
        for _, opt := range options </span><span class="cov8" title="1">{
                opt(config)
        }</span>
        <span class="cov8" title="1">return *config</span>
}

var AvailableWindowsSIGDistros []Distro = []Distro{
        AKSWindows2019,
        AKSWindows2019Containerd,
        AKSWindows2022Containerd,
        AKSWindows2022ContainerdGen2,
        CustomizedWindowsOSImage,
}

var AvailableWindowsPIRDistros []Distro = []Distro{
        AKSWindows2019PIR,
}

// SIG const
const (
        AKSSIGImagePublisher           string = "microsoft-aks"
        AKSWindowsGalleryName          string = "AKSWindows"
        AKSWindowsResourceGroup        string = "AKS-Windows"
        AKSUbuntuGalleryName           string = "AKSUbuntu"
        AKSUbuntuResourceGroup         string = "AKS-Ubuntu"
        AKSCBLMarinerGalleryName       string = "AKSCBLMariner"
        AKSCBLMarinerResourceGroup     string = "AKS-CBLMariner"
        AKSUbuntuEdgeZoneGalleryName   string = "AKSUbuntuEdgeZone"
        AKSUbuntuEdgeZoneResourceGroup string = "AKS-Ubuntu-EdgeZone"
)

const (
        // DO NOT MODIFY: used for freezing linux images with docker
        FrozenLinuxSIGImageVersionForDocker string = "2022.08.29"

        // We do not use AKS Windows image versions in AgentBaker. These fake values are only used for unit tests
        Windows2019SIGImageVersion string = "17763.2019.221114"
        Windows2022SIGImageVersion string = "20348.2022.221114"
)

type sigVersion struct {
        OSType  string `json:"ostype"`
        Version string `json:"version"`
}

//go:embed linux_sig_version.json
var linuxVersionJSONContentsEmbedded string

//go:embed edge_zone_sig_version.json
var edgeZoneJSONContentsEmbedded string

//go:embed mariner_v2_kata_gen2_tl_sig_version.json
var marinerV2KataGen2TLJSONContentsEmbedded string

var LinuxSIGImageVersion = getSIGVersionFromEmbeddedString(linuxVersionJSONContentsEmbedded)
var EdgeZoneSIGImageVersion = getSIGVersionFromEmbeddedString(edgeZoneJSONContentsEmbedded)
var CBLMarinerV2KataGen2TLSIGImageVersion = getSIGVersionFromEmbeddedString(marinerV2KataGen2TLJSONContentsEmbedded)

func getSIGVersionFromEmbeddedString(contents string) string <span class="cov8" title="1">{

        if len(contents) == 0 </span><span class="cov0" title="0">{
                panic("SIG version is empty")</span>
        }

        <span class="cov8" title="1">var sigImageStruct sigVersion
        err := json.Unmarshal([]byte(contents), &amp;sigImageStruct)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">sigImageVersion := sigImageStruct.Version
        return sigImageVersion</span>
}

// SIG config Template
var (
        SIGUbuntu1604ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1604",
                Version:       "2021.11.06",
        }

        SIGUbuntu1804ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804",
                Version:       FrozenLinuxSIGImageVersionForDocker,
        }

        SIGUbuntu1804Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gen2",
                Version:       FrozenLinuxSIGImageVersionForDocker,
        }

        SIGUbuntuGPU1804ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gpu",
                Version:       FrozenLinuxSIGImageVersionForDocker,
        }

        SIGUbuntuGPU1804Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gen2gpu",
                Version:       FrozenLinuxSIGImageVersionForDocker,
        }

        SIGUbuntuContainerd1804ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804containerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuContainerd1804Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gen2containerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuGPUContainerd1804ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gpucontainerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuGPUContainerd1804Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gen2gpucontainerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuFipsContainerd1804ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804fipscontainerd",
                Version:       LinuxSIGImageVersion,
        }

        // not a typo, this image was generated on 2021.05.20 UTC and assigned this version
        SIGUbuntuFipsContainerd1804Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gen2fipscontainerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuFipsGPUContainerd1804ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804fipsgpucontainerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuFipsGPUContainerd1804Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gen2fipsgpucontainerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuFipsContainerd2004ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "2004fipscontainerd",
                Version:       LinuxSIGImageVersion,
        }

        // not a typo, this image was generated on 2021.05.20 UTC and assigned this version
        SIGUbuntuFipsContainerd2004Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "2004gen2fipscontainerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuArm64Containerd1804Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "1804gen2arm64containerd",
                Version:       LinuxSIGImageVersion,
        }

        // This image is using a specific resource group and gallery name for edge zone scenario.
        SIGUbuntuEdgeZoneContainerd1804ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuEdgeZoneResourceGroup,
                Gallery:       AKSUbuntuEdgeZoneGalleryName,
                Definition:    "1804containerd",
                Version:       EdgeZoneSIGImageVersion,
        }

        // This image is using a specific resource group and gallery name for edge zone scenario.
        SIGUbuntuEdgeZoneContainerd1804Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuEdgeZoneResourceGroup,
                Gallery:       AKSUbuntuEdgeZoneGalleryName,
                Definition:    "1804gen2containerd",
                Version:       EdgeZoneSIGImageVersion,
        }

        SIGUbuntuArm64Containerd2204Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "2204gen2arm64containerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuContainerd2204ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "2204containerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuContainerd2204Gen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "2204gen2containerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuContainerd2204TLGen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "2204gen2TLcontainerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGUbuntuContainerd2004CVMGen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSUbuntuResourceGroup,
                Gallery:       AKSUbuntuGalleryName,
                Definition:    "2004gen2CVMcontainerd",
                Version:       LinuxSIGImageVersion,
        }

        SIGCBLMarinerV1ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSCBLMarinerResourceGroup,
                Gallery:       AKSCBLMarinerGalleryName,
                Definition:    "V1",
                Version:       LinuxSIGImageVersion,
        }

        SIGCBLMarinerV2Gen1ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSCBLMarinerResourceGroup,
                Gallery:       AKSCBLMarinerGalleryName,
                Definition:    "V2",
                Version:       LinuxSIGImageVersion,
        }

        SIGCBLMarinerV2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSCBLMarinerResourceGroup,
                Gallery:       AKSCBLMarinerGalleryName,
                Definition:    "V2gen2",
                Version:       LinuxSIGImageVersion,
        }

        SIGCBLMarinerV2KataImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSCBLMarinerResourceGroup,
                Gallery:       AKSCBLMarinerGalleryName,
                Definition:    "V2katagen2",
                Version:       LinuxSIGImageVersion,
        }

        SIGCBLMarinerV2Arm64ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSCBLMarinerResourceGroup,
                Gallery:       AKSCBLMarinerGalleryName,
                Definition:    "V2gen2arm64",
                Version:       LinuxSIGImageVersion,
        }

        SIGCBLMarinerV2TLImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSCBLMarinerResourceGroup,
                Gallery:       AKSCBLMarinerGalleryName,
                Definition:    "V2gen2TL",
                Version:       LinuxSIGImageVersion,
        }

        SIGCBLMarinerV2KataGen2TLImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSCBLMarinerResourceGroup,
                Gallery:       AKSCBLMarinerGalleryName,
                Definition:    "V2katagen2TL",
                Version:       CBLMarinerV2KataGen2TLSIGImageVersion,
        }

        SIGWindows2019ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSWindowsResourceGroup,
                Gallery:       AKSWindowsGalleryName,
                Definition:    "windows-2019",
                Version:       Windows2019SIGImageVersion,
        }

        SIGWindows2019ContainerdImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSWindowsResourceGroup,
                Gallery:       AKSWindowsGalleryName,
                Definition:    "windows-2019-containerd",
                Version:       Windows2019SIGImageVersion,
        }

        SIGWindows2022ContainerdImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSWindowsResourceGroup,
                Gallery:       AKSWindowsGalleryName,
                Definition:    "windows-2022-containerd",
                Version:       Windows2022SIGImageVersion,
        }

        SIGWindows2022ContainerdGen2ImageConfigTemplate = SigImageConfigTemplate{
                ResourceGroup: AKSWindowsResourceGroup,
                Gallery:       AKSWindowsGalleryName,
                Definition:    "windows-2022-containerd-gen2",
                Version:       Windows2022SIGImageVersion,
        }
)

func getSigUbuntuImageConfigMapWithOpts(opts ...SigImageConfigOpt) map[Distro]SigImageConfig <span class="cov8" title="1">{
        return map[Distro]SigImageConfig{
                AKSUbuntu1604:                      SIGUbuntu1604ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntu1804:                      SIGUbuntu1804ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntu1804Gen2:                  SIGUbuntu1804Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuGPU1804:                   SIGUbuntuGPU1804ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuGPU1804Gen2:               SIGUbuntuGPU1804Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuContainerd1804:            SIGUbuntuContainerd1804ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuContainerd1804Gen2:        SIGUbuntuContainerd1804Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuGPUContainerd1804:         SIGUbuntuGPUContainerd1804ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuGPUContainerd1804Gen2:     SIGUbuntuGPUContainerd1804Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuFipsContainerd1804:        SIGUbuntuFipsContainerd1804ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuFipsContainerd1804Gen2:    SIGUbuntuFipsContainerd1804Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuFipsContainerd2004:        SIGUbuntuFipsContainerd2004ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuFipsContainerd2004Gen2:    SIGUbuntuFipsContainerd2004Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuFipsGPUContainerd1804:     SIGUbuntuFipsGPUContainerd1804ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuFipsGPUContainerd1804Gen2: SIGUbuntuFipsGPUContainerd1804Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuArm64Containerd1804Gen2:   SIGUbuntuArm64Containerd1804Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuContainerd2204:            SIGUbuntuContainerd2204ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuContainerd2204Gen2:        SIGUbuntuContainerd2204Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuContainerd2004CVMGen2:     SIGUbuntuContainerd2004CVMGen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuArm64Containerd2204Gen2:   SIGUbuntuArm64Containerd2204Gen2ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuContainerd2204TLGen2:      SIGUbuntuContainerd2204TLGen2ImageConfigTemplate.WithOptions(opts...),
        }
}</span>
func getSigCBLMarinerImageConfigMapWithOpts(opts ...SigImageConfigOpt) map[Distro]SigImageConfig <span class="cov8" title="1">{
        return map[Distro]SigImageConfig{
                AKSCBLMarinerV1:           SIGCBLMarinerV1ImageConfigTemplate.WithOptions(opts...),
                AKSCBLMarinerV2:           SIGCBLMarinerV2Gen1ImageConfigTemplate.WithOptions(opts...),
                AKSCBLMarinerV2Gen2:       SIGCBLMarinerV2ImageConfigTemplate.WithOptions(opts...),
                AKSCBLMarinerV2Gen2Kata:   SIGCBLMarinerV2KataImageConfigTemplate.WithOptions(opts...),
                AKSCBLMarinerV2Arm64Gen2:  SIGCBLMarinerV2Arm64ImageConfigTemplate.WithOptions(opts...),
                AKSCBLMarinerV2Gen2TL:     SIGCBLMarinerV2TLImageConfigTemplate.WithOptions(opts...),
                AKSCBLMarinerV2KataGen2TL: SIGCBLMarinerV2KataGen2TLImageConfigTemplate.WithOptions(opts...),
        }
}</span>

func getSigWindowsImageConfigMapWithOpts(opts ...SigImageConfigOpt) map[Distro]SigImageConfig <span class="cov8" title="1">{
        return map[Distro]SigImageConfig{
                AKSWindows2019:               SIGWindows2019ImageConfigTemplate.WithOptions(opts...),
                AKSWindows2019Containerd:     SIGWindows2019ContainerdImageConfigTemplate.WithOptions(opts...),
                AKSWindows2022Containerd:     SIGWindows2022ContainerdImageConfigTemplate.WithOptions(opts...),
                AKSWindows2022ContainerdGen2: SIGWindows2022ContainerdGen2ImageConfigTemplate.WithOptions(opts...),
        }
}</span>

func getSigUbuntuEdgeZoneImageConfigMapWithOpts(opts ...SigImageConfigOpt) map[Distro]SigImageConfig <span class="cov8" title="1">{
        return map[Distro]SigImageConfig{
                AKSUbuntuEdgeZoneContainerd1804:     SIGUbuntuEdgeZoneContainerd1804ImageConfigTemplate.WithOptions(opts...),
                AKSUbuntuEdgeZoneContainerd1804Gen2: SIGUbuntuEdgeZoneContainerd1804Gen2ImageConfigTemplate.WithOptions(opts...),
        }
}</span>

// GetSIGAzureCloudSpecConfig get cloud specific sig config
func GetSIGAzureCloudSpecConfig(sigConfig SIGConfig, region string) (SIGAzureEnvironmentSpecConfig, error) <span class="cov8" title="1">{
        if sigConfig.Galleries == nil || strings.EqualFold(sigConfig.SubscriptionID, "") || strings.EqualFold(sigConfig.TenantID, "") </span><span class="cov0" title="0">{
                return SIGAzureEnvironmentSpecConfig{}, fmt.Errorf("acsConfig.rpConfig.sigConfig missing expected values - cannot generate sig env config")
        }</span>

        <span class="cov8" title="1">c := new(SIGAzureEnvironmentSpecConfig)
        c.SigTenantID = sigConfig.TenantID
        c.SubscriptionID = sigConfig.SubscriptionID
        c.CloudName = GetCloudTargetEnv(region)

        fromACSUbuntu, err := withACSSIGConfig(sigConfig, "AKSUbuntu")
        if err != nil </span><span class="cov0" title="0">{
                return SIGAzureEnvironmentSpecConfig{}, fmt.Errorf("unexpected error while constructing env-aware sig configuration for AKSUbuntu: %s", err)
        }</span>
        <span class="cov8" title="1">c.SigUbuntuImageConfig = getSigUbuntuImageConfigMapWithOpts(fromACSUbuntu)

        fromACSCBLMariner, err := withACSSIGConfig(sigConfig, "AKSCBLMariner")
        if err != nil </span><span class="cov0" title="0">{
                return SIGAzureEnvironmentSpecConfig{}, fmt.Errorf("unexpected error while constructing env-aware sig configuration for AKSCBLMariner: %s", err)
        }</span>
        <span class="cov8" title="1">c.SigCBLMarinerImageConfig = getSigCBLMarinerImageConfigMapWithOpts(fromACSCBLMariner)

        fromACSWindows, err := withACSSIGConfig(sigConfig, "AKSWindows")
        if err != nil </span><span class="cov0" title="0">{
                return SIGAzureEnvironmentSpecConfig{}, fmt.Errorf("unexpected error while constructing env-aware sig configuration for Windows: %s", err)
        }</span>
        <span class="cov8" title="1">c.SigWindowsImageConfig = getSigWindowsImageConfigMapWithOpts(fromACSWindows)

        fromACSUbuntuEdgeZone := withEdgeZoneConfig(sigConfig)
        c.SigUbuntuEdgeZoneImageConfig = getSigUbuntuEdgeZoneImageConfigMapWithOpts(fromACSUbuntuEdgeZone)
        return *c, nil</span>
}

// GetAzurePublicSIGConfigForTest returns a statically defined sigconfig. This should only be used for unit tests and e2es.
func GetAzurePublicSIGConfigForTest() SIGAzureEnvironmentSpecConfig <span class="cov0" title="0">{
        return SIGAzureEnvironmentSpecConfig{
                CloudName:                    AzurePublicCloud,
                SigTenantID:                  AzurePublicCloudSigTenantID,
                SubscriptionID:               AzurePublicCloudSigSubscription,
                SigUbuntuImageConfig:         getSigUbuntuImageConfigMapWithOpts(withSubscription(AzurePublicCloudSigSubscription)),
                SigCBLMarinerImageConfig:     getSigCBLMarinerImageConfigMapWithOpts(withSubscription(AzurePublicCloudSigSubscription)),
                SigWindowsImageConfig:        getSigWindowsImageConfigMapWithOpts(withSubscription(AzurePublicCloudSigSubscription)),
                SigUbuntuEdgeZoneImageConfig: getSigUbuntuEdgeZoneImageConfigMapWithOpts(withSubscription(AzurePublicCloudSigSubscription)),
        }
}</span>

func withACSSIGConfig(acsSigConfig SIGConfig, osSKU string) (SigImageConfigOpt, error) <span class="cov8" title="1">{
        gallery, k := acsSigConfig.Galleries[osSKU]
        if !k </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sig gallery configuration for %s not found", osSKU)
        }</span>
        <span class="cov8" title="1">return func(c *SigImageConfig) </span><span class="cov8" title="1">{
                c.Gallery = gallery.GalleryName
                c.SubscriptionID = acsSigConfig.SubscriptionID
                c.ResourceGroup = gallery.ResourceGroup
        }</span>, nil
}

func withEdgeZoneConfig(acsSigConfig SIGConfig) SigImageConfigOpt <span class="cov8" title="1">{
        return func(c *SigImageConfig) </span><span class="cov8" title="1">{
                c.Gallery = AKSUbuntuEdgeZoneGalleryName
                c.SubscriptionID = acsSigConfig.SubscriptionID
                c.ResourceGroup = AKSUbuntuEdgeZoneResourceGroup
        }</span>
}

func withSubscription(subscriptionID string) SigImageConfigOpt <span class="cov0" title="0">{
        return func(c *SigImageConfig) </span><span class="cov0" title="0">{
                c.SubscriptionID = subscriptionID
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package datamodel

import (
        "bytes"
        "encoding/json"
        "fmt"
        "hash/fnv"
        "math/rand"
        neturl "net/url"
        "sort"
        "strings"
        "sync"

        "github.com/Azure/go-autorest/autorest/to"
)

// TypeMeta describes an individual API model object
type TypeMeta struct {
        // APIVersion is on every object
        APIVersion string `json:"apiVersion"`
}

// CustomSearchDomain represents the Search Domain when the custom vnet has a windows server DNS as a nameserver.
type CustomSearchDomain struct {
        Name          string `json:"name,omitempty"`
        RealmUser     string `json:"realmUser,omitempty"`
        RealmPassword string `json:"realmPassword,omitempty"`
}

// PublicKey represents an SSH key for LinuxProfile
type PublicKey struct {
        KeyData string `json:"keyData"`
}

// KeyVaultCertificate specifies a certificate to install
// On Linux, the certificate file is placed under the /var/lib/waagent directory
// with the file name &lt;UppercaseThumbprint&gt;.crt for the X509 certificate file
// and &lt;UppercaseThumbprint&gt;.prv for the private key. Both of these files are .pem formatted.
// On windows the certificate will be saved in the specified store.
type KeyVaultCertificate struct {
        CertificateURL   string `json:"certificateUrl,omitempty"`
        CertificateStore string `json:"certificateStore,omitempty"`
}

// KeyVaultID specifies a key vault
type KeyVaultID struct {
        ID string `json:"id,omitempty"`
}

// KeyVaultRef represents a reference to KeyVault instance on Azure
type KeyVaultRef struct {
        KeyVault      KeyVaultID `json:"keyVault"`
        SecretName    string     `json:"secretName"`
        SecretVersion string     `json:"secretVersion,omitempty"`
}

// KeyVaultSecrets specifies certificates to install on the pool
// of machines from a given key vault
// the key vault specified must have been granted read permissions to CRP
type KeyVaultSecrets struct {
        SourceVault       *KeyVaultID           `json:"sourceVault,omitempty"`
        VaultCertificates []KeyVaultCertificate `json:"vaultCertificates,omitempty"`
}

// ImageReference represents a reference to an Image resource in Azure.
type ImageReference struct {
        Name           string `json:"name,omitempty"`
        ResourceGroup  string `json:"resourceGroup,omitempty"`
        SubscriptionID string `json:"subscriptionId,omitempty"`
        Gallery        string `json:"gallery,omitempty"`
        Version        string `json:"version,omitempty"`
}

// VMDiagnostics contains settings to on/off boot diagnostics collection
// in RD Host
type VMDiagnostics struct {
        Enabled bool `json:"enabled"`

        // Specifies storage account Uri where Boot Diagnostics (CRP &amp;
        // VMSS BootDiagostics) and VM Diagnostics logs (using Linux
        // Diagnostics Extension) will be stored. Uri will be of standard
        // blob domain. i.e. https://storageaccount.blob.core.windows.net/
        // This field is readonly as ACS RP will create a storage account
        // for the customer.
        StorageURL *neturl.URL `json:"storageUrl"`
}

// OSType represents OS types of agents
type OSType string

// the OSTypes supported by vlabs
const (
        Windows OSType = "Windows"
        Linux   OSType = "Linux"
)

// KubeletDiskType describes options for placement of the primary kubelet partition,
// docker images, emptyDir volumes, and pod logs.
type KubeletDiskType string

const (
        // OSDisk indicates data wil be shared with the OS.
        OSDisk KubeletDiskType = "OS"
        // TempDisk indicates date will be isolated on the temporary disk.
        TempDisk KubeletDiskType = "Temporary"
)

// WorkloadRuntime describes choices for the type of workload: container or wasm-wasi, currently.
type WorkloadRuntime string

const (
        // OCIContainer indicates that kubelet will be used for a container workload.
        OCIContainer WorkloadRuntime = "OCIContainer"
        // WasmWasi indicates Krustlet will be used for a WebAssembly workload.
        WasmWasi WorkloadRuntime = "WasmWasi"
)

// These are the flags set by RP that should NOT be included
// within the set of command line flags when configuring kubelet
var CommandLineOmittedKubeletConfigFlags map[string]bool = map[string]bool{
        "--node-status-report-frequency": true,
}

// Distro represents Linux distro to use for Linux VMs
type Distro string

// Distro string consts
const (
        Ubuntu                              Distro = "ubuntu"
        Ubuntu1804                          Distro = "ubuntu-18.04"
        Ubuntu1804Gen2                      Distro = "ubuntu-18.04-gen2"
        AKSUbuntu1804Gen2                   Distro = "ubuntu-18.04-gen2" // same distro as Ubuntu1804Gen2, renamed for clarity
        AKSUbuntu1604                       Distro = "aks-ubuntu-16.04"
        AKSUbuntu1804                       Distro = "aks-ubuntu-18.04"
        AKSUbuntuGPU1804                    Distro = "aks-ubuntu-gpu-18.04"
        AKSUbuntuGPU1804Gen2                Distro = "aks-ubuntu-gpu-18.04-gen2"
        AKSUbuntuContainerd1804             Distro = "aks-ubuntu-containerd-18.04"
        AKSUbuntuContainerd1804Gen2         Distro = "aks-ubuntu-containerd-18.04-gen2"
        AKSUbuntuGPUContainerd1804          Distro = "aks-ubuntu-gpu-containerd-18.04"
        AKSUbuntuGPUContainerd1804Gen2      Distro = "aks-ubuntu-gpu-containerd-18.04-gen2"
        AKSCBLMarinerV1                     Distro = "aks-cblmariner-v1"
        AKSCBLMarinerV2                     Distro = "aks-cblmariner-v2"
        AKSCBLMarinerV2Gen2                 Distro = "aks-cblmariner-v2-gen2"
        AKSCBLMarinerV2Gen2Kata             Distro = "aks-cblmariner-v2-gen2-kata"
        AKSCBLMarinerV2Gen2TL               Distro = "aks-cblmariner-v2-gen2-tl"
        AKSCBLMarinerV2KataGen2TL           Distro = "aks-cblmariner-v2-kata-gen2-tl"
        AKSUbuntuFipsContainerd1804         Distro = "aks-ubuntu-fips-containerd-18.04"
        AKSUbuntuFipsContainerd1804Gen2     Distro = "aks-ubuntu-fips-containerd-18.04-gen2"
        AKSUbuntuFipsContainerd2004         Distro = "aks-ubuntu-fips-containerd-20.04"
        AKSUbuntuFipsContainerd2004Gen2     Distro = "aks-ubuntu-fips-containerd-20.04-gen2"
        AKSUbuntuFipsGPUContainerd1804      Distro = "aks-ubuntu-fips-gpu-containerd-18.04"
        AKSUbuntuFipsGPUContainerd1804Gen2  Distro = "aks-ubuntu-fips-gpu-containerd-18.04-gen2"
        AKSUbuntuArm64Containerd1804Gen2    Distro = "aks-ubuntu-arm64-containerd-18.04-gen2"
        AKSUbuntuEdgeZoneContainerd1804     Distro = "aks-ubuntu-edgezone-containerd-18.04"
        AKSUbuntuEdgeZoneContainerd1804Gen2 Distro = "aks-ubuntu-edgezone-containerd-18.04-gen2"
        AKSUbuntuContainerd2204             Distro = "aks-ubuntu-containerd-22.04"
        AKSUbuntuContainerd2204Gen2         Distro = "aks-ubuntu-containerd-22.04-gen2"
        AKSUbuntuContainerd2004CVMGen2      Distro = "aks-ubuntu-containerd-20.04-cvm-gen2"
        AKSUbuntuArm64Containerd2204Gen2    Distro = "aks-ubuntu-arm64-containerd-22.04-gen2"
        AKSCBLMarinerV2Arm64Gen2            Distro = "aks-cblmariner-v2-arm64-gen2"
        AKSUbuntuContainerd2204TLGen2       Distro = "aks-ubuntu-containerd-22.04-tl-gen2"
        RHEL                                Distro = "rhel"
        CoreOS                              Distro = "coreos"
        AKS1604Deprecated                   Distro = "aks"      // deprecated AKS 16.04 distro. Equivalent to aks-ubuntu-16.04.
        AKS1804Deprecated                   Distro = "aks-1804" // deprecated AKS 18.04 distro. Equivalent to aks-ubuntu-18.04.

        // Windows string const
        // AKSWindows2019 stands for distro of windows server 2019 SIG image with docker
        AKSWindows2019 Distro = "aks-windows-2019"
        // AKSWindows2019Containerd stands for distro for windows server 2019 SIG image with containerd
        AKSWindows2019Containerd Distro = "aks-windows-2019-containerd"
        // AKSWindows2022Containerd stands for distro for windows server 2022 SIG image with containerd
        AKSWindows2022Containerd Distro = "aks-windows-2022-containerd"
        // AKSWindows2022ContainerdGen2 stands for distro for windows server 2022 Gen 2 SIG image with containerd
        AKSWindows2022ContainerdGen2 Distro = "aks-windows-2022-containerd-gen2"
        // AKSWindows2019PIR stands for distro of windows server 2019 PIR image with docker
        AKSWindows2019PIR        Distro = "aks-windows-2019-pir"
        CustomizedImage          Distro = "CustomizedImage"
        CustomizedWindowsOSImage Distro = "CustomizedWindowsOSImage"

        // USNatCloud is a const string reference identifier for USNat
        USNatCloud = "USNatCloud"
        // USSecCloud is a const string reference identifier for USSec
        USSecCloud = "USSecCloud"
)

var AKSDistrosAvailableOnVHD []Distro = []Distro{
        AKSUbuntu1604,
        AKSUbuntu1804,
        AKSUbuntu1804Gen2,
        AKSUbuntuGPU1804,
        AKSUbuntuGPU1804Gen2,
        AKSUbuntuContainerd1804,
        AKSUbuntuContainerd1804Gen2,
        AKSUbuntuGPUContainerd1804,
        AKSUbuntuGPUContainerd1804Gen2,
        AKSCBLMarinerV1,
        AKSCBLMarinerV2,
        AKSCBLMarinerV2Gen2,
        AKSCBLMarinerV2Gen2Kata,
        AKSCBLMarinerV2Gen2TL,
        AKSCBLMarinerV2KataGen2TL,
        AKSUbuntuFipsContainerd1804,
        AKSUbuntuFipsContainerd1804Gen2,
        AKSUbuntuFipsContainerd2004,
        AKSUbuntuFipsContainerd2004Gen2,
        AKSUbuntuFipsGPUContainerd1804,
        AKSUbuntuFipsGPUContainerd1804Gen2,
        AKSUbuntuArm64Containerd1804Gen2,
        AKSUbuntuEdgeZoneContainerd1804,
        AKSUbuntuEdgeZoneContainerd1804Gen2,
        AKSUbuntuContainerd2204,
        AKSUbuntuContainerd2204Gen2,
        AKSUbuntuContainerd2004CVMGen2,
        AKSUbuntuArm64Containerd2204Gen2,
        AKSCBLMarinerV2Arm64Gen2,
        AKSUbuntuContainerd2204TLGen2,
}

type CustomConfigurationComponent string

const (
        ComponentkubeProxy CustomConfigurationComponent = "kube-proxy"
        Componentkubelet   CustomConfigurationComponent = "kubelet"
)

func (d Distro) IsVHDDistro() bool <span class="cov8" title="1">{
        for _, distro := range AKSDistrosAvailableOnVHD </span><span class="cov8" title="1">{
                if d == distro </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (d Distro) Is2204VHDDistro() bool <span class="cov8" title="1">{
        for _, distro := range AvailableUbuntu2204Distros </span><span class="cov8" title="1">{
                if d == distro </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (d Distro) IsKataDistro() bool <span class="cov0" title="0">{
        return d == AKSCBLMarinerV2Gen2Kata
}</span>

// KeyvaultSecretRef specifies path to the Azure keyvault along with secret name and (optionaly) version
// for Service Principal's secret
type KeyvaultSecretRef struct {
        VaultID       string `json:"vaultID"`
        SecretName    string `json:"secretName"`
        SecretVersion string `json:"version,omitempty"`
}

// AuthenticatorType represents the authenticator type the cluster was
// set up with.
type AuthenticatorType string

const (
        // OIDC represent cluster setup in OIDC auth mode
        OIDC AuthenticatorType = "oidc"
        // Webhook represent cluster setup in wehhook auth mode
        Webhook AuthenticatorType = "webhook"
)

// UserAssignedIdentity contains information that uniquely identifies an identity
type UserAssignedIdentity struct {
        ResourceID string `json:"resourceId,omitempty"`
        ClientID   string `json:"clientId,omitempty"`
        ObjectID   string `json:"objectId,omitempty"`
}

// ResourceIdentifiers represents resource ids
type ResourceIdentifiers struct {
        Graph               string `json:"graph,omitempty"`
        KeyVault            string `json:"keyVault,omitempty"`
        Datalake            string `json:"datalake,omitempty"`
        Batch               string `json:"batch,omitempty"`
        OperationalInsights string `json:"operationalInsights,omitempty"`
        Storage             string `json:"storage,omitempty"`
}

// CustomCloudEnv represents the custom cloud env info of the AKS cluster.
type CustomCloudEnv struct {
        // TODO(ace): why is Name uppercase?
        // in Linux, this was historically specified as "name" when serialized.
        // However Windows relies on the json tag as "Name"
        // TODO(ace): can we align on one casing?
        SnakeCaseName                string              `json:"name,omitempty"`
        Name                         string              `json:"Name,omitempty"`
        McrURL                       string              `json:"mcrURL,omitempty"`
        RepoDepotEndpoint            string              `json:"repoDepotEndpoint,omitempty"`
        ManagementPortalURL          string              `json:"managementPortalURL,omitempty"`
        PublishSettingsURL           string              `json:"publishSettingsURL,omitempty"`
        ServiceManagementEndpoint    string              `json:"serviceManagementEndpoint,omitempty"`
        ResourceManagerEndpoint      string              `json:"resourceManagerEndpoint,omitempty"`
        ActiveDirectoryEndpoint      string              `json:"activeDirectoryEndpoint,omitempty"`
        GalleryEndpoint              string              `json:"galleryEndpoint,omitempty"`
        KeyVaultEndpoint             string              `json:"keyVaultEndpoint,omitempty"`
        GraphEndpoint                string              `json:"graphEndpoint,omitempty"`
        ServiceBusEndpoint           string              `json:"serviceBusEndpoint,omitempty"`
        BatchManagementEndpoint      string              `json:"batchManagementEndpoint,omitempty"`
        StorageEndpointSuffix        string              `json:"storageEndpointSuffix,omitempty"`
        SQLDatabaseDNSSuffix         string              `json:"sqlDatabaseDNSSuffix,omitempty"`
        TrafficManagerDNSSuffix      string              `json:"trafficManagerDNSSuffix,omitempty"`
        KeyVaultDNSSuffix            string              `json:"keyVaultDNSSuffix,omitempty"`
        ServiceBusEndpointSuffix     string              `json:"serviceBusEndpointSuffix,omitempty"`
        ServiceManagementVMDNSSuffix string              `json:"serviceManagementVMDNSSuffix,omitempty"`
        ResourceManagerVMDNSSuffix   string              `json:"resourceManagerVMDNSSuffix,omitempty"`
        ContainerRegistryDNSSuffix   string              `json:"containerRegistryDNSSuffix,omitempty"`
        CosmosDBDNSSuffix            string              `json:"cosmosDBDNSSuffix,omitempty"`
        TokenAudience                string              `json:"tokenAudience,omitempty"`
        ResourceIdentifiers          ResourceIdentifiers `json:"resourceIdentifiers,omitempty"`
}

// FeatureFlags defines feature-flag restricted functionality
type FeatureFlags struct {
        EnableCSERunInBackground bool `json:"enableCSERunInBackground,omitempty"`
        BlockOutboundInternet    bool `json:"blockOutboundInternet,omitempty"`
        EnableIPv6DualStack      bool `json:"enableIPv6DualStack,omitempty"`
        EnableIPv6Only           bool `json:"enableIPv6Only,omitempty"`
        EnableWinDSR             bool `json:"enableWinDSR,omitempty"`
}

// AddonProfile represents an addon for managed cluster
type AddonProfile struct {
        Enabled bool              `json:"enabled"`
        Config  map[string]string `json:"config"`
        // Identity contains information of the identity associated with this addon.
        // This property will only appear in an MSI-enabled cluster.
        Identity *UserAssignedIdentity `json:"identity,omitempty"`
}

// HostedMasterProfile defines properties for a hosted master
type HostedMasterProfile struct {
        // Master public endpoint/FQDN with port
        // The format will be FQDN:2376
        // Not used during PUT, returned as part of GETFQDN
        FQDN string `json:"fqdn,omitempty"`
        // IPAddress
        // if both FQDN and IPAddress are specified, we should use IPAddress
        IPAddress string `json:"ipAddress,omitempty"`
        DNSPrefix string `json:"dnsPrefix"`
        // FQDNSubdomain is used by private cluster without dnsPrefix so they have fixed FQDN
        FQDNSubdomain string `json:"fqdnSubdomain"`
        // Subnet holds the CIDR which defines the Azure Subnet in which
        // Agents will be provisioned. This is stored on the HostedMasterProfile
        // and will become `masterSubnet` in the compiled template.
        Subnet string `json:"subnet"`
        // ApiServerWhiteListRange is a comma delimited CIDR which is whitelisted to AKS
        APIServerWhiteListRange *string `json:"apiServerWhiteListRange"`
        IPMasqAgent             bool    `json:"ipMasqAgent"`
}

// CustomProfile specifies custom properties that are used for
// cluster instantiation.  Should not be used by most users.
type CustomProfile struct {
        Orchestrator string `json:"orchestrator,omitempty"`
}

// AADProfile specifies attributes for AAD integration
type AADProfile struct {
        // The client AAD application ID.
        ClientAppID string `json:"clientAppID,omitempty"`
        // The server AAD application ID.
        ServerAppID string `json:"serverAppID,omitempty"`
        // The server AAD application secret
        ServerAppSecret string `json:"serverAppSecret,omitempty" conform:"redact"`
        // The AAD tenant ID to use for authentication.
        // If not specified, will use the tenant of the deployment subscription.
        // Optional
        TenantID string `json:"tenantID,omitempty"`
        // The Azure Active Directory Group Object ID that will be assigned the
        // cluster-admin RBAC role.
        // Optional
        AdminGroupID string `json:"adminGroupID,omitempty"`
        // The authenticator to use, either "oidc" or "webhook".
        Authenticator AuthenticatorType `json:"authenticator"`
}

// CertificateProfile represents the definition of the master cluster
type CertificateProfile struct {
        // CaCertificate is the certificate authority certificate.
        CaCertificate string `json:"caCertificate,omitempty" conform:"redact"`
        // ApiServerCertificate is the rest api server certificate, and signed by the CA
        APIServerCertificate string `json:"apiServerCertificate,omitempty" conform:"redact"`
        // ClientCertificate is the certificate used by the client kubelet services and signed by the CA
        ClientCertificate string `json:"clientCertificate,omitempty" conform:"redact"`
        // ClientPrivateKey is the private key used by the client kubelet services and signed by the CA
        ClientPrivateKey string `json:"clientPrivateKey,omitempty" conform:"redact"`
        // KubeConfigCertificate is the client certificate used for kubectl cli and signed by the CA
        KubeConfigCertificate string `json:"kubeConfigCertificate,omitempty" conform:"redact"`
        // KubeConfigPrivateKey is the client private key used for kubectl cli and signed by the CA
        KubeConfigPrivateKey string `json:"kubeConfigPrivateKey,omitempty" conform:"redact"`
}

// ServicePrincipalProfile contains the client and secret used by the cluster for Azure Resource CRUD
type ServicePrincipalProfile struct {
        ClientID          string             `json:"clientId"`
        Secret            string             `json:"secret,omitempty" conform:"redact"`
        ObjectID          string             `json:"objectId,omitempty"`
        KeyvaultSecretRef *KeyvaultSecretRef `json:"keyvaultSecretRef,omitempty"`
}

// DiagnosticsProfile setting to enable/disable capturing
// diagnostics for VMs hosting container cluster.
type DiagnosticsProfile struct {
        VMDiagnostics *VMDiagnostics `json:"vmDiagnostics"`
}

// ExtensionProfile represents an extension definition
type ExtensionProfile struct {
        Name                           string             `json:"name"`
        Version                        string             `json:"version"`
        ExtensionParameters            string             `json:"extensionParameters,omitempty"`
        ExtensionParametersKeyVaultRef *KeyvaultSecretRef `json:"parametersKeyvaultSecretRef,omitempty"`
        RootURL                        string             `json:"rootURL,omitempty"`
        // This is only needed for preprovision extensions and it needs to be a bash script
        Script   string `json:"script,omitempty"`
        URLQuery string `json:"urlQuery,omitempty"`
}

// ResourcePurchasePlan defines resource plan as required by ARM
// for billing purposes.
type ResourcePurchasePlan struct {
        Name          string `json:"name"`
        Product       string `json:"product"`
        PromotionCode string `json:"promotionCode"`
        Publisher     string `json:"publisher"`
}

// WindowsProfile represents the windows parameters passed to the cluster
type WindowsProfile struct {
        AdminUsername                  string                     `json:"adminUsername"`
        AdminPassword                  string                     `json:"adminPassword" conform:"redact"`
        CSIProxyURL                    string                     `json:"csiProxyURL,omitempty"`
        EnableCSIProxy                 *bool                      `json:"enableCSIProxy,omitempty"`
        ImageRef                       *ImageReference            `json:"imageReference,omitempty"`
        ImageVersion                   string                     `json:"imageVersion"`
        ProvisioningScriptsPackageURL  string                     `json:"provisioningScriptsPackageURL,omitempty"`
        WindowsImageSourceURL          string                     `json:"windowsImageSourceURL"`
        WindowsPublisher               string                     `json:"windowsPublisher"`
        WindowsOffer                   string                     `json:"windowsOffer"`
        WindowsSku                     string                     `json:"windowsSku"`
        WindowsDockerVersion           string                     `json:"windowsDockerVersion"`
        Secrets                        []KeyVaultSecrets          `json:"secrets,omitempty"`
        SSHEnabled                     *bool                      `json:"sshEnabled,omitempty"`
        EnableAutomaticUpdates         *bool                      `json:"enableAutomaticUpdates,omitempty"`
        IsCredentialAutoGenerated      *bool                      `json:"isCredentialAutoGenerated,omitempty"`
        EnableAHUB                     *bool                      `json:"enableAHUB,omitempty"`
        WindowsPauseImageURL           string                     `json:"windowsPauseImageURL"`
        AlwaysPullWindowsPauseImage    *bool                      `json:"alwaysPullWindowsPauseImage,omitempty"`
        ContainerdWindowsRuntimes      *ContainerdWindowsRuntimes `json:"containerdWindowsRuntimes,omitempty"`
        WindowsCalicoPackageURL        string                     `json:"windowsCalicoPackageURL,omitempty"`
        WindowsSecureTlsEnabled        *bool                      `json:"windowsSecureTlsEnabled,omitempty"`
        WindowsGmsaPackageUrl          string                     `json:"windowsGmsaPackageUrl,omitempty"`
        CseScriptsPackageURL           string                     `json:"cseScriptsPackageURL,omitempty"`
        HnsRemediatorIntervalInMinutes *uint32                    `json:"hnsRemediatorIntervalInMinutes,omitempty"`
        LogGeneratorIntervalInMinutes  *uint32                    `json:"logGeneratorIntervalInMinutes,omitempty"`
}

// ContainerdWindowsRuntimes configures containerd runtimes that are available on the windows nodes
type ContainerdWindowsRuntimes struct {
        DefaultSandboxIsolation string            `json:"defaultSandboxIsolation,omitempty"`
        RuntimeHandlers         []RuntimeHandlers `json:"runtimesHandlers,omitempty"`
}

// RuntimeHandlers configures the runtime settings in containerd
type RuntimeHandlers struct {
        BuildNumber string `json:"buildNumber,omitempty"`
}

// LinuxProfile represents the linux parameters passed to the cluster
type LinuxProfile struct {
        AdminUsername string `json:"adminUsername"`
        SSH           struct {
                PublicKeys []PublicKey `json:"publicKeys"`
        } `json:"ssh"`
        Secrets            []KeyVaultSecrets   `json:"secrets,omitempty"`
        Distro             Distro              `json:"distro,omitempty"`
        CustomSearchDomain *CustomSearchDomain `json:"customSearchDomain,omitempty"`
}

// Extension represents an extension definition in the master or agentPoolProfile
type Extension struct {
        Name        string `json:"name"`
        SingleOrAll string `json:"singleOrAll"`
        Template    string `json:"template"`
}

// PrivateJumpboxProfile represents a jumpbox definition
type PrivateJumpboxProfile struct {
        Name           string `json:"name" validate:"required"`
        VMSize         string `json:"vmSize" validate:"required"`
        OSDiskSizeGB   int    `json:"osDiskSizeGB,omitempty" validate:"min=0,max=2048"`
        Username       string `json:"username,omitempty"`
        PublicKey      string `json:"publicKey" validate:"required"`
        StorageProfile string `json:"storageProfile,omitempty"`
}

// PrivateCluster defines the configuration for a private cluster
type PrivateCluster struct {
        Enabled                *bool                  `json:"enabled,omitempty"`
        EnableHostsConfigAgent *bool                  `json:"enableHostsConfigAgent,omitempty"`
        JumpboxProfile         *PrivateJumpboxProfile `json:"jumpboxProfile,omitempty"`
}

// KubernetesContainerSpec defines configuration for a container spec
type KubernetesContainerSpec struct {
        Name           string `json:"name,omitempty"`
        Image          string `json:"image,omitempty"`
        CPURequests    string `json:"cpuRequests,omitempty"`
        MemoryRequests string `json:"memoryRequests,omitempty"`
        CPULimits      string `json:"cpuLimits,omitempty"`
        MemoryLimits   string `json:"memoryLimits,omitempty"`
}

// AddonNodePoolsConfig defines configuration for pool-specific cluster-autoscaler configuration
type AddonNodePoolsConfig struct {
        Name   string            `json:"name,omitempty"`
        Config map[string]string `json:"config,omitempty"`
}

// KubernetesAddon defines a list of addons w/ configuration to include with the cluster deployment
type KubernetesAddon struct {
        Name       string                    `json:"name,omitempty"`
        Enabled    *bool                     `json:"enabled,omitempty"`
        Mode       string                    `json:"mode,omitempty"`
        Containers []KubernetesContainerSpec `json:"containers,omitempty"`
        Config     map[string]string         `json:"config,omitempty"`
        Pools      []AddonNodePoolsConfig    `json:"pools,omitempty"`
        Data       string                    `json:"data,omitempty"`
}

// KubernetesConfig contains the Kubernetes config structure, containing
// Kubernetes specific configuration
type KubernetesConfig struct {
        KubernetesImageBase               string            `json:"kubernetesImageBase,omitempty"`
        MCRKubernetesImageBase            string            `json:"mcrKubernetesImageBase,omitempty"`
        ClusterSubnet                     string            `json:"clusterSubnet,omitempty"`
        NetworkPolicy                     string            `json:"networkPolicy,omitempty"`
        NetworkPlugin                     string            `json:"networkPlugin,omitempty"`
        NetworkMode                       string            `json:"networkMode,omitempty"`
        ContainerRuntime                  string            `json:"containerRuntime,omitempty"`
        MaxPods                           int               `json:"maxPods,omitempty"`
        DockerBridgeSubnet                string            `json:"dockerBridgeSubnet,omitempty"`
        DNSServiceIP                      string            `json:"dnsServiceIP,omitempty"`
        ServiceCIDR                       string            `json:"serviceCidr,omitempty"`
        UseManagedIdentity                bool              `json:"useManagedIdentity,omitempty"`
        UserAssignedID                    string            `json:"userAssignedID,omitempty"`
        UserAssignedClientID              string            `json:"userAssignedClientID,omitempty"` // Note: cannot be provided in config. Used *only* for transferring this to azure.json.
        CustomHyperkubeImage              string            `json:"customHyperkubeImage,omitempty"`
        CustomKubeProxyImage              string            `json:"customKubeProxyImage,omitempty"`
        CustomKubeBinaryURL               string            `json:"customKubeBinaryURL,omitempty"`
        MobyVersion                       string            `json:"mobyVersion,omitempty"`
        ContainerdVersion                 string            `json:"containerdVersion,omitempty"`
        WindowsNodeBinariesURL            string            `json:"windowsNodeBinariesURL,omitempty"`
        WindowsContainerdURL              string            `json:"windowsContainerdURL,omitempty"`
        WindowsSdnPluginURL               string            `json:"windowsSdnPluginURL,omitempty"`
        UseInstanceMetadata               *bool             `json:"useInstanceMetadata,omitempty"`
        EnableRbac                        *bool             `json:"enableRbac,omitempty"`
        EnableSecureKubelet               *bool             `json:"enableSecureKubelet,omitempty"`
        PrivateCluster                    *PrivateCluster   `json:"privateCluster,omitempty"`
        GCHighThreshold                   int               `json:"gchighthreshold,omitempty"`
        GCLowThreshold                    int               `json:"gclowthreshold,omitempty"`
        EnableEncryptionWithExternalKms   *bool             `json:"enableEncryptionWithExternalKms,omitempty"`
        Addons                            []KubernetesAddon `json:"addons,omitempty"`
        ContainerRuntimeConfig            map[string]string `json:"containerRuntimeConfig,omitempty"`
        ControllerManagerConfig           map[string]string `json:"controllerManagerConfig,omitempty"`
        SchedulerConfig                   map[string]string `json:"schedulerConfig,omitempty"`
        CloudProviderBackoffMode          string            `json:"cloudProviderBackoffMode"`
        CloudProviderBackoff              *bool             `json:"cloudProviderBackoff,omitempty"`
        CloudProviderBackoffRetries       int               `json:"cloudProviderBackoffRetries,omitempty"`
        CloudProviderBackoffJitter        float64           `json:"cloudProviderBackoffJitter,omitempty"`
        CloudProviderBackoffDuration      int               `json:"cloudProviderBackoffDuration,omitempty"`
        CloudProviderBackoffExponent      float64           `json:"cloudProviderBackoffExponent,omitempty"`
        CloudProviderRateLimit            *bool             `json:"cloudProviderRateLimit,omitempty"`
        CloudProviderRateLimitQPS         float64           `json:"cloudProviderRateLimitQPS,omitempty"`
        CloudProviderRateLimitQPSWrite    float64           `json:"cloudProviderRateLimitQPSWrite,omitempty"`
        CloudProviderRateLimitBucket      int               `json:"cloudProviderRateLimitBucket,omitempty"`
        CloudProviderRateLimitBucketWrite int               `json:"cloudProviderRateLimitBucketWrite,omitempty"`
        CloudProviderDisableOutboundSNAT  *bool             `json:"cloudProviderDisableOutboundSNAT,omitempty"`
        NodeStatusUpdateFrequency         string            `json:"nodeStatusUpdateFrequency,omitempty"`
        LoadBalancerSku                   string            `json:"loadBalancerSku,omitempty"`
        ExcludeMasterFromStandardLB       *bool             `json:"excludeMasterFromStandardLB,omitempty"`
        AzureCNIURLLinux                  string            `json:"azureCNIURLLinux,omitempty"`
        AzureCNIURLARM64Linux             string            `json:"azureCNIURLARM64Linux,omitempty"`
        AzureCNIURLWindows                string            `json:"azureCNIURLWindows,omitempty"`
        MaximumLoadBalancerRuleCount      int               `json:"maximumLoadBalancerRuleCount,omitempty"`
        PrivateAzureRegistryServer        string            `json:"privateAzureRegistryServer,omitempty"`
        NetworkPluginMode                 string            `json:"networkPluginMode,omitempty"`
}

// CustomFile has source as the full absolute source path to a file and dest
// is the full absolute desired destination path to put the file on a master node
type CustomFile struct {
        Source string `json:"source,omitempty"`
        Dest   string `json:"dest,omitempty"`
}

// OrchestratorProfile contains Orchestrator properties
type OrchestratorProfile struct {
        OrchestratorType    string            `json:"orchestratorType"`
        OrchestratorVersion string            `json:"orchestratorVersion"`
        KubernetesConfig    *KubernetesConfig `json:"kubernetesConfig,omitempty"`
}

// ProvisioningState represents the current state of container service resource.
type ProvisioningState string

// CustomKubeletConfig represents custom kubelet configurations for agent pool nodes
type CustomKubeletConfig struct {
        CPUManagerPolicy      string    `json:"cpuManagerPolicy,omitempty"`
        CPUCfsQuota           *bool     `json:"cpuCfsQuota,omitempty"`
        CPUCfsQuotaPeriod     string    `json:"cpuCfsQuotaPeriod,omitempty"`
        ImageGcHighThreshold  *int32    `json:"imageGcHighThreshold,omitempty"`
        ImageGcLowThreshold   *int32    `json:"imageGcLowThreshold,omitempty"`
        TopologyManagerPolicy string    `json:"topologyManagerPolicy,omitempty"`
        AllowedUnsafeSysctls  *[]string `json:"allowedUnsafeSysctls,omitempty"`
        FailSwapOn            *bool     `json:"failSwapOn,omitempty"`
        ContainerLogMaxSizeMB *int32    `json:"containerLogMaxSizeMB,omitempty"`
        ContainerLogMaxFiles  *int32    `json:"containerLogMaxFiles,omitempty"`
        PodMaxPids            *int32    `json:"podMaxPids,omitempty"`
}

// CustomLinuxOSConfig represents custom os configurations for agent pool nodes
type CustomLinuxOSConfig struct {
        Sysctls                    *SysctlConfig `json:"sysctls,omitempty"`
        TransparentHugePageEnabled string        `json:"transparentHugePageEnabled,omitempty"`
        TransparentHugePageDefrag  string        `json:"transparentHugePageDefrag,omitempty"`
        SwapFileSizeMB             *int32        `json:"swapFileSizeMB,omitempty"`
}

// SysctlConfig represents sysctl configs in customLinuxOsConfig
type SysctlConfig struct {
        NetCoreSomaxconn               *int32 `json:"netCoreSomaxconn,omitempty"`
        NetCoreNetdevMaxBacklog        *int32 `json:"netCoreNetdevMaxBacklog,omitempty"`
        NetCoreRmemDefault             *int32 `json:"netCoreRmemDefault,omitempty"`
        NetCoreRmemMax                 *int32 `json:"netCoreRmemMax,omitempty"`
        NetCoreWmemDefault             *int32 `json:"netCoreWmemDefault,omitempty"`
        NetCoreWmemMax                 *int32 `json:"netCoreWmemMax,omitempty"`
        NetCoreOptmemMax               *int32 `json:"netCoreOptmemMax,omitempty"`
        NetIpv4TcpMaxSynBacklog        *int32 `json:"netIpv4TcpMaxSynBacklog,omitempty"`
        NetIpv4TcpMaxTwBuckets         *int32 `json:"netIpv4TcpMaxTwBuckets,omitempty"`
        NetIpv4TcpFinTimeout           *int32 `json:"netIpv4TcpFinTimeout,omitempty"`
        NetIpv4TcpKeepaliveTime        *int32 `json:"netIpv4TcpKeepaliveTime,omitempty"`
        NetIpv4TcpKeepaliveProbes      *int32 `json:"netIpv4TcpKeepaliveProbes,omitempty"`
        NetIpv4TcpkeepaliveIntvl       *int32 `json:"netIpv4TcpkeepaliveIntvl,omitempty"`
        NetIpv4TcpTwReuse              *bool  `json:"netIpv4TcpTwReuse,omitempty"`
        NetIpv4IpLocalPortRange        string `json:"netIpv4IpLocalPortRange,omitempty"`
        NetIpv4NeighDefaultGcThresh1   *int32 `json:"netIpv4NeighDefaultGcThresh1,omitempty"`
        NetIpv4NeighDefaultGcThresh2   *int32 `json:"netIpv4NeighDefaultGcThresh2,omitempty"`
        NetIpv4NeighDefaultGcThresh3   *int32 `json:"netIpv4NeighDefaultGcThresh3,omitempty"`
        NetNetfilterNfConntrackMax     *int32 `json:"netNetfilterNfConntrackMax,omitempty"`
        NetNetfilterNfConntrackBuckets *int32 `json:"netNetfilterNfConntrackBuckets,omitempty"`
        FsInotifyMaxUserWatches        *int32 `json:"fsInotifyMaxUserWatches,omitempty"`
        FsFileMax                      *int32 `json:"fsFileMax,omitempty"`
        FsAioMaxNr                     *int32 `json:"fsAioMaxNr,omitempty"`
        FsNrOpen                       *int32 `json:"fsNrOpen,omitempty"`
        KernelThreadsMax               *int32 `json:"kernelThreadsMax,omitempty"`
        VMMaxMapCount                  *int32 `json:"vmMaxMapCount,omitempty"`
        VMSwappiness                   *int32 `json:"vmSwappiness,omitempty"`
        VMVfsCachePressure             *int32 `json:"vmVfsCachePressure,omitempty"`
}

type CustomConfiguration struct {
        KubernetesConfigurations        map[string]*ComponentConfiguration
        WindowsKubernetesConfigurations map[string]*ComponentConfiguration
}

type ComponentConfiguration struct {
        Image       *string
        Config      map[string]string
        DownloadURL *string
}

// AgentPoolProfile represents an agent pool definition
type AgentPoolProfile struct {
        Name                  string               `json:"name"`
        VMSize                string               `json:"vmSize"`
        KubeletDiskType       KubeletDiskType      `json:"kubeletDiskType,omitempty"`
        WorkloadRuntime       WorkloadRuntime      `json:"workloadRuntime,omitempty"`
        DNSPrefix             string               `json:"dnsPrefix,omitempty"`
        OSType                OSType               `json:"osType,omitempty"`
        Ports                 []int                `json:"ports,omitempty"`
        AvailabilityProfile   string               `json:"availabilityProfile"`
        StorageProfile        string               `json:"storageProfile,omitempty"`
        VnetSubnetID          string               `json:"vnetSubnetID,omitempty"`
        Distro                Distro               `json:"distro,omitempty"`
        CustomNodeLabels      map[string]string    `json:"customNodeLabels,omitempty"`
        PreprovisionExtension *Extension           `json:"preProvisionExtension"`
        KubernetesConfig      *KubernetesConfig    `json:"kubernetesConfig,omitempty"`
        VnetCidrs             []string             `json:"vnetCidrs,omitempty"`
        WindowsNameVersion    string               `json:"windowsNameVersion,omitempty"`
        CustomKubeletConfig   *CustomKubeletConfig `json:"customKubeletConfig,omitempty"`
        CustomLinuxOSConfig   *CustomLinuxOSConfig `json:"customLinuxOSConfig,omitempty"`
        MessageOfTheDay       string               `json:"messageOfTheDay,omitempty"`
        // This is a new property and all old agent pools do no have this field. We need to keep the default
        // behavior to reboot Windows node when it is nil
        NotRebootWindowsNode    *bool                    `json:"notRebootWindowsNode,omitempty"`
        AgentPoolWindowsProfile *AgentPoolWindowsProfile `json:"agentPoolWindowsProfile,omitempty"`
}

// Properties represents the AKS cluster definition
type Properties struct {
        ClusterID               string
        ProvisioningState       ProvisioningState        `json:"provisioningState,omitempty"`
        OrchestratorProfile     *OrchestratorProfile     `json:"orchestratorProfile,omitempty"`
        AgentPoolProfiles       []*AgentPoolProfile      `json:"agentPoolProfiles,omitempty"`
        LinuxProfile            *LinuxProfile            `json:"linuxProfile,omitempty"`
        WindowsProfile          *WindowsProfile          `json:"windowsProfile,omitempty"`
        ExtensionProfiles       []*ExtensionProfile      `json:"extensionProfiles"`
        DiagnosticsProfile      *DiagnosticsProfile      `json:"diagnosticsProfile,omitempty"`
        ServicePrincipalProfile *ServicePrincipalProfile `json:"servicePrincipalProfile,omitempty"`
        CertificateProfile      *CertificateProfile      `json:"certificateProfile,omitempty"`
        AADProfile              *AADProfile              `json:"aadProfile,omitempty"`
        CustomProfile           *CustomProfile           `json:"customProfile,omitempty"`
        HostedMasterProfile     *HostedMasterProfile     `json:"hostedMasterProfile,omitempty"`
        AddonProfiles           map[string]AddonProfile  `json:"addonProfiles,omitempty"`
        FeatureFlags            *FeatureFlags            `json:"featureFlags,omitempty"`
        CustomCloudEnv          *CustomCloudEnv          `json:"customCloudEnv,omitempty"`
        CustomConfiguration     *CustomConfiguration     `json:"customConfiguration,omitempty"`
}

// ContainerService complies with the ARM model of
// resource definition in a JSON template.
type ContainerService struct {
        ID       string                `json:"id"`
        Location string                `json:"location"`
        Name     string                `json:"name"`
        Plan     *ResourcePurchasePlan `json:"plan,omitempty"`
        Tags     map[string]string     `json:"tags"`
        Type     string                `json:"type"`

        Properties *Properties `json:"properties,omitempty"`
}

// IsAKSCustomCloud checks if it's in AKS custom cloud
func (cs *ContainerService) IsAKSCustomCloud() bool <span class="cov0" title="0">{
        return cs.Properties.CustomCloudEnv != nil &amp;&amp;
                strings.EqualFold(cs.Properties.CustomCloudEnv.Name, "akscustom")
}</span>

// HasAadProfile returns true if the has aad profile
func (p *Properties) HasAadProfile() bool <span class="cov8" title="1">{
        return p.AADProfile != nil
}</span>

// GetCustomCloudName returns name of environment if customCloudProfile is provided, returns empty string if customCloudProfile is empty.
// Because customCloudProfile is empty for deployment is AzurePublicCloud, AzureChinaCloud,AzureGermanCloud,AzureUSGovernmentCloud,
// the return value will be empty string for those clouds
func (p *Properties) GetCustomCloudName() string <span class="cov0" title="0">{
        var cloudProfileName string
        if p.IsAKSCustomCloud() </span><span class="cov0" title="0">{
                cloudProfileName = p.CustomCloudEnv.Name
        }</span>
        <span class="cov0" title="0">return cloudProfileName</span>
}

// IsIPMasqAgentDisabled returns true if the ip-masq-agent functionality is disabled
func (p *Properties) IsIPMasqAgentDisabled() bool <span class="cov8" title="1">{
        if p.HostedMasterProfile != nil </span><span class="cov8" title="1">{
                return !p.HostedMasterProfile.IPMasqAgent
        }</span>
        <span class="cov8" title="1">if p.OrchestratorProfile != nil &amp;&amp; p.OrchestratorProfile.KubernetesConfig != nil </span><span class="cov8" title="1">{
                return p.OrchestratorProfile.KubernetesConfig.IsIPMasqAgentDisabled()
        }</span>
        <span class="cov8" title="1">return false</span>
}

// HasWindows returns true if the cluster contains windows
func (p *Properties) HasWindows() bool <span class="cov8" title="1">{
        for _, agentPoolProfile := range p.AgentPoolProfiles </span><span class="cov8" title="1">{
                if strings.EqualFold(string(agentPoolProfile.OSType), string(Windows)) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsAKSCustomCloud checks if it's in AKS custom cloud
func (p *Properties) IsAKSCustomCloud() bool <span class="cov8" title="1">{
        return p.CustomCloudEnv != nil &amp;&amp;
                strings.EqualFold(p.CustomCloudEnv.Name, "akscustom")
}</span>

// IsIPMasqAgentEnabled returns true if the cluster has a hosted master and IpMasqAgent is disabled
func (p *Properties) IsIPMasqAgentEnabled() bool <span class="cov8" title="1">{
        if p.HostedMasterProfile != nil </span><span class="cov8" title="1">{
                return p.HostedMasterProfile.IPMasqAgent
        }</span>
        <span class="cov8" title="1">return p.OrchestratorProfile.KubernetesConfig.IsIPMasqAgentEnabled()</span>
}

// GetClusterID creates a unique 8 string cluster ID.
func (p *Properties) GetClusterID() string <span class="cov8" title="1">{
        mutex := &amp;sync.Mutex{}
        if p.ClusterID == "" </span><span class="cov8" title="1">{
                uniqueNameSuffixSize := 8
                // the name suffix uniquely identifies the cluster and is generated off a hash
                // from the master dns name
                h := fnv.New64a()
                if p.HostedMasterProfile != nil </span><span class="cov8" title="1">{
                        h.Write([]byte(p.HostedMasterProfile.DNSPrefix))
                }</span> else<span class="cov8" title="1"> if len(p.AgentPoolProfiles) &gt; 0 </span><span class="cov8" title="1">{
                        h.Write([]byte(p.AgentPoolProfiles[0].Name))
                }</span>
                <span class="cov8" title="1">r := rand.New(rand.NewSource(int64(h.Sum64())))
                mutex.Lock()
                p.ClusterID = fmt.Sprintf("%08d", r.Uint32())[:uniqueNameSuffixSize]
                mutex.Unlock()</span>
        }
        <span class="cov8" title="1">return p.ClusterID</span>
}

// AreAgentProfilesCustomVNET returns true if all of the agent profiles in the clusters are configured with VNET.
func (p *Properties) AreAgentProfilesCustomVNET() bool <span class="cov8" title="1">{
        if p.AgentPoolProfiles != nil </span><span class="cov8" title="1">{
                for _, agentPoolProfile := range p.AgentPoolProfiles </span><span class="cov8" title="1">{
                        if !agentPoolProfile.IsCustomVNET() </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetCustomEnvironmentJSON return the JSON format string for custom environment
func (p *Properties) GetCustomEnvironmentJSON(escape bool) (string, error) <span class="cov8" title="1">{
        var environmentJSON string
        if p.IsAKSCustomCloud() </span><span class="cov8" title="1">{
                // Workaround to set correct name in AzureStackCloud.json
                oldName := p.CustomCloudEnv.Name
                p.CustomCloudEnv.Name = AzureStackCloud
                p.CustomCloudEnv.SnakeCaseName = AzureStackCloud
                defer func() </span><span class="cov8" title="1">{
                        // Restore p.CustomCloudEnv to old value
                        p.CustomCloudEnv.Name = oldName
                }</span>()
                <span class="cov8" title="1">bytes, err := json.Marshal(p.CustomCloudEnv)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("could not serialize CustomCloudEnv object - %s", err.Error())
                }</span>
                <span class="cov8" title="1">environmentJSON = string(bytes)
                if escape </span><span class="cov0" title="0">{
                        environmentJSON = strings.Replace(environmentJSON, "\"", "\\\"", -1)
                }</span>
        }
        <span class="cov8" title="1">return environmentJSON, nil</span>
}

// HasDCSeriesSKU returns whether or not there is an DC series SKU agent pool
func (p *Properties) HasDCSeriesSKU() bool <span class="cov8" title="1">{
        for _, profile := range p.AgentPoolProfiles </span><span class="cov8" title="1">{
                if strings.Contains(profile.VMSize, "Standard_DC") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// K8sOrchestratorName returns the 3 character orchestrator code for kubernetes-based clusters.
func (p *Properties) K8sOrchestratorName() string <span class="cov8" title="1">{
        if p.OrchestratorProfile.IsKubernetes() </span><span class="cov8" title="1">{
                if p.HostedMasterProfile != nil </span><span class="cov8" title="1">{
                        return DefaultHostedProfileMasterName
                }</span>
                <span class="cov0" title="0">return DefaultOrchestratorName</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// IsVHDDistroForAllNodes returns true if all of the agent pools plus masters are running the VHD image
func (p *Properties) IsVHDDistroForAllNodes() bool <span class="cov8" title="1">{
        if len(p.AgentPoolProfiles) &gt; 0 </span><span class="cov8" title="1">{
                for _, ap := range p.AgentPoolProfiles </span><span class="cov8" title="1">{
                        if !ap.IsVHDDistro() </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// GetVMType returns the type of VM "vmss" or "standard" to be passed to the cloud provider
func (p *Properties) GetVMType() string <span class="cov8" title="1">{
        if p.HasVMSSAgentPool() </span><span class="cov8" title="1">{
                return VMSSVMType
        }</span>
        <span class="cov8" title="1">return StandardVMType</span>
}

// HasVMSSAgentPool returns true if the cluster contains Virtual Machine Scale Sets agent pools
func (p *Properties) HasVMSSAgentPool() bool <span class="cov8" title="1">{
        for _, agentPoolProfile := range p.AgentPoolProfiles </span><span class="cov8" title="1">{
                if strings.EqualFold(agentPoolProfile.AvailabilityProfile, VirtualMachineScaleSets) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetSubnetName returns the subnet name of the cluster based on its current configuration.
func (p *Properties) GetSubnetName() string <span class="cov8" title="1">{
        var subnetName string

        if p.AreAgentProfilesCustomVNET() </span><span class="cov8" title="1">{
                subnetName = strings.Split(p.AgentPoolProfiles[0].VnetSubnetID, "/")[DefaultSubnetNameResourceSegmentIndex]
        }</span> else<span class="cov8" title="1"> {
                subnetName = p.K8sOrchestratorName() + "-subnet"
        }</span>

        <span class="cov8" title="1">return subnetName</span>
}

// GetNSGName returns the name of the network security group of the cluster.
func (p *Properties) GetNSGName() string <span class="cov8" title="1">{
        return p.GetResourcePrefix() + "nsg"
}</span>

// GetResourcePrefix returns the prefix to use for naming cluster resources
func (p *Properties) GetResourcePrefix() string <span class="cov8" title="1">{
        return p.K8sOrchestratorName() + "-agentpool-" + p.GetClusterID() + "-"
}</span>

// GetVirtualNetworkName returns the virtual network name of the cluster
func (p *Properties) GetVirtualNetworkName() string <span class="cov8" title="1">{
        var vnetName string
        if p.AreAgentProfilesCustomVNET() </span><span class="cov8" title="1">{
                vnetName = strings.Split(p.AgentPoolProfiles[0].VnetSubnetID, "/")[DefaultVnetNameResourceSegmentIndex]
        }</span> else<span class="cov8" title="1"> {
                vnetName = p.K8sOrchestratorName() + "-vnet-" + p.GetClusterID()
        }</span>
        <span class="cov8" title="1">return vnetName</span>
}

// GetVNetResourceGroupName returns the virtual network resource group name of the cluster
func (p *Properties) GetVNetResourceGroupName() string <span class="cov8" title="1">{
        var vnetResourceGroupName string
        if p.AreAgentProfilesCustomVNET() </span><span class="cov8" title="1">{
                vnetResourceGroupName = strings.Split(p.AgentPoolProfiles[0].VnetSubnetID, "/")[DefaultVnetResourceGroupSegmentIndex]
        }</span>
        <span class="cov8" title="1">return vnetResourceGroupName</span>
}

// GetRouteTableName returns the route table name of the cluster.
func (p *Properties) GetRouteTableName() string <span class="cov8" title="1">{
        return p.GetResourcePrefix() + "routetable"
}</span>

// GetPrimaryAvailabilitySetName returns the name of the primary availability set of the cluster
func (p *Properties) GetPrimaryAvailabilitySetName() string <span class="cov8" title="1">{
        if len(p.AgentPoolProfiles) &gt; 0 </span><span class="cov8" title="1">{
                if strings.EqualFold(p.AgentPoolProfiles[0].AvailabilityProfile, AvailabilitySet) </span><span class="cov8" title="1">{
                        return p.AgentPoolProfiles[0].Name + "-availabilitySet-" + p.GetClusterID()
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (p *Properties) GetComponentKubernetesConfiguration(component CustomConfigurationComponent) *ComponentConfiguration <span class="cov0" title="0">{
        if p.CustomConfiguration == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if p.CustomConfiguration.KubernetesConfigurations == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if configuration, ok := p.CustomConfiguration.KubernetesConfigurations[string(component)]; ok </span><span class="cov0" title="0">{
                return configuration
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *Properties) GetComponentWindowsKubernetesConfiguration(component CustomConfigurationComponent) *ComponentConfiguration <span class="cov8" title="1">{
        if p.CustomConfiguration == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if p.CustomConfiguration.WindowsKubernetesConfigurations == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if configuration, ok := p.CustomConfiguration.WindowsKubernetesConfigurations[string(component)]; ok </span><span class="cov8" title="1">{
                return configuration
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetKubeProxyFeatureGatesWindowsArguments returns the feature gates string for the kube-proxy arguments in Windows nodes
func (p *Properties) GetKubeProxyFeatureGatesWindowsArguments() string <span class="cov8" title="1">{
        featureGates := map[string]bool{}

        if p.FeatureFlags.IsFeatureEnabled("EnableIPv6DualStack") </span><span class="cov8" title="1">{
                featureGates["IPv6DualStack"] = true
        }</span>
        <span class="cov8" title="1">if p.FeatureFlags.IsFeatureEnabled("EnableWinDSR") </span><span class="cov8" title="1">{
                // WinOverlay must be set to false
                featureGates["WinDSR"] = true
                featureGates["WinOverlay"] = false
        }</span>

        <span class="cov8" title="1">keys := []string{}
        for key := range featureGates </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        var buf bytes.Buffer
        for _, key := range keys </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("\"%s=%t\", ", key, featureGates[key]))
        }</span>
        <span class="cov8" title="1">return strings.TrimSuffix(buf.String(), ", ")</span>
}

// IsVHDDistro returns true if the distro uses VHD SKUs
func (a *AgentPoolProfile) IsVHDDistro() bool <span class="cov8" title="1">{
        return a.Distro.IsVHDDistro()
}</span>

// Is2204VHDDistro returns true if the distro uses 2204 VHD
func (a *AgentPoolProfile) Is2204VHDDistro() bool <span class="cov8" title="1">{
        return a.Distro.Is2204VHDDistro()
}</span>

// IsCustomVNET returns true if the customer brought their own VNET
func (a *AgentPoolProfile) IsCustomVNET() bool <span class="cov8" title="1">{
        return len(a.VnetSubnetID) &gt; 0
}</span>

// IsWindows returns true if the agent pool is windows
func (a *AgentPoolProfile) IsWindows() bool <span class="cov8" title="1">{
        return strings.EqualFold(string(a.OSType), string(Windows))
}</span>

// IsVirtualMachineScaleSets returns true if the agent pool availability profile is VMSS
func (a *AgentPoolProfile) IsVirtualMachineScaleSets() bool <span class="cov8" title="1">{
        return strings.EqualFold(a.AvailabilityProfile, VirtualMachineScaleSets)
}</span>

// IsAvailabilitySets returns true if the customer specified disks
func (a *AgentPoolProfile) IsAvailabilitySets() bool <span class="cov8" title="1">{
        return strings.EqualFold(a.AvailabilityProfile, AvailabilitySet)
}</span>

// GetKubernetesLabels returns a k8s API-compliant labels string for nodes in this profile
func (a *AgentPoolProfile) GetKubernetesLabels(rg string, deprecated bool, nvidiaEnabled bool, fipsEnabled bool, osSku string) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        buf.WriteString(fmt.Sprintf("agentpool=%s", a.Name))
        buf.WriteString(fmt.Sprintf(",kubernetes.azure.com/agentpool=%s", a.Name))

        keys := []string{}
        for key := range a.CustomNodeLabels </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        for _, key := range keys </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf(",%s=%s", key, a.CustomNodeLabels[key]))
        }</span>
        <span class="cov8" title="1">return buf.String()</span>
}

// HasSecrets returns true if the customer specified secrets to install
func (l *LinuxProfile) HasSecrets() bool <span class="cov8" title="1">{
        return len(l.Secrets) &gt; 0
}</span>

// HasSearchDomain returns true if the customer specified secrets to install
func (l *LinuxProfile) HasSearchDomain() bool <span class="cov8" title="1">{
        if l.CustomSearchDomain != nil </span><span class="cov8" title="1">{
                if l.CustomSearchDomain.Name != "" &amp;&amp; l.CustomSearchDomain.RealmPassword != "" &amp;&amp; l.CustomSearchDomain.RealmUser != "" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsAzureCNI returns true if Azure CNI network plugin is enabled
func (o *OrchestratorProfile) IsAzureCNI() bool <span class="cov8" title="1">{
        if o.KubernetesConfig != nil </span><span class="cov8" title="1">{
                return strings.EqualFold(o.KubernetesConfig.NetworkPlugin, NetworkPluginAzure)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsNoneCNI returns true if network plugin none is enabled
func (o *OrchestratorProfile) IsNoneCNI() bool <span class="cov8" title="1">{
        if o.KubernetesConfig != nil </span><span class="cov8" title="1">{
                return strings.EqualFold(o.KubernetesConfig.NetworkPlugin, NetworkPluginNone)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsCSIProxyEnabled returns true if csi proxy service should be enable for Windows nodes
func (w *WindowsProfile) IsCSIProxyEnabled() bool <span class="cov8" title="1">{
        if w.EnableCSIProxy != nil </span><span class="cov8" title="1">{
                return *w.EnableCSIProxy
        }</span>
        <span class="cov8" title="1">return DefaultEnableCSIProxyWindows</span>
}

// HasSecrets returns true if the customer specified secrets to install
func (w *WindowsProfile) HasSecrets() bool <span class="cov8" title="1">{
        return len(w.Secrets) &gt; 0
}</span>

// HasCustomImage returns true if there is a custom windows os image url specified
func (w *WindowsProfile) HasCustomImage() bool <span class="cov8" title="1">{
        return len(w.WindowsImageSourceURL) &gt; 0
}</span>

// GetSSHEnabled gets it ssh should be enabled for Windows nodes
func (w *WindowsProfile) GetSSHEnabled() bool <span class="cov8" title="1">{
        if w.SSHEnabled != nil </span><span class="cov8" title="1">{
                return *w.SSHEnabled
        }</span>
        <span class="cov0" title="0">return DefaultWindowsSSHEnabled</span>
}

// HasImageRef returns true if the customer brought os image
func (w *WindowsProfile) HasImageRef() bool <span class="cov8" title="1">{
        return w.ImageRef != nil &amp;&amp; w.ImageRef.IsValid()
}</span>

// GetWindowsSku gets the marketplace sku specified (such as Datacenter-Core-1809-with-Containers-smalldisk) or returns default value
func (w *WindowsProfile) GetWindowsSku() string <span class="cov8" title="1">{
        if w.WindowsSku != "" </span><span class="cov8" title="1">{
                return w.WindowsSku
        }</span>
        <span class="cov8" title="1">return KubernetesDefaultWindowsSku</span>
}

// GetWindowsDockerVersion gets the docker version specified or returns default value
func (w *WindowsProfile) GetWindowsDockerVersion() string <span class="cov8" title="1">{
        if w.WindowsDockerVersion != "" </span><span class="cov8" title="1">{
                return w.WindowsDockerVersion
        }</span>
        <span class="cov8" title="1">return KubernetesWindowsDockerVersion</span>
}

// GetDefaultContainerdWindowsSandboxIsolation gets the default containerd runtime handler or return default value
func (w *WindowsProfile) GetDefaultContainerdWindowsSandboxIsolation() string <span class="cov8" title="1">{
        if w.ContainerdWindowsRuntimes != nil &amp;&amp; w.ContainerdWindowsRuntimes.DefaultSandboxIsolation != "" </span><span class="cov0" title="0">{
                return w.ContainerdWindowsRuntimes.DefaultSandboxIsolation
        }</span>

        <span class="cov8" title="1">return KubernetesDefaultContainerdWindowsSandboxIsolation</span>
}

// GetContainerdWindowsRuntimeHandlers gets comma separated list of runtimehandler names
func (w *WindowsProfile) GetContainerdWindowsRuntimeHandlers() string <span class="cov8" title="1">{
        if w.ContainerdWindowsRuntimes != nil &amp;&amp; len(w.ContainerdWindowsRuntimes.RuntimeHandlers) &gt; 0 </span><span class="cov0" title="0">{
                handlernames := []string{}
                for _, h := range w.ContainerdWindowsRuntimes.RuntimeHandlers </span><span class="cov0" title="0">{
                        handlernames = append(handlernames, h.BuildNumber)
                }</span>
                <span class="cov0" title="0">return strings.Join(handlernames, ",")</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// IsAlwaysPullWindowsPauseImage returns true if the windows pause image always needs a force pull
func (w *WindowsProfile) IsAlwaysPullWindowsPauseImage() bool <span class="cov8" title="1">{
        return w.AlwaysPullWindowsPauseImage != nil &amp;&amp; *w.AlwaysPullWindowsPauseImage
}</span>

// IsWindowsSecureTlsEnabled returns true if secure TLS should be enabled for Windows nodes
func (w *WindowsProfile) IsWindowsSecureTlsEnabled() bool <span class="cov0" title="0">{
        if w.WindowsSecureTlsEnabled != nil </span><span class="cov0" title="0">{
                return *w.WindowsSecureTlsEnabled
        }</span>
        <span class="cov0" title="0">return DefaultWindowsSecureTlsEnabled</span>
}

// GetHnsRemediatorIntervalInMinutes gets HnsRemediatorIntervalInMinutes specified or returns default value
func (w *WindowsProfile) GetHnsRemediatorIntervalInMinutes() uint32 <span class="cov0" title="0">{
        if w.HnsRemediatorIntervalInMinutes != nil </span><span class="cov0" title="0">{
                return *w.HnsRemediatorIntervalInMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetLogGeneratorIntervalInMinutes gets LogGeneratorIntervalInMinutes specified or returns default value
func (w *WindowsProfile) GetLogGeneratorIntervalInMinutes() uint32 <span class="cov0" title="0">{
        if w.LogGeneratorIntervalInMinutes != nil </span><span class="cov0" title="0">{
                return *w.LogGeneratorIntervalInMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// IsKubernetes returns true if this template is for Kubernetes orchestrator
func (o *OrchestratorProfile) IsKubernetes() bool <span class="cov8" title="1">{
        return strings.EqualFold(o.OrchestratorType, Kubernetes)
}</span>

// IsFeatureEnabled returns true if a feature flag is on for the provided feature
func (f *FeatureFlags) IsFeatureEnabled(feature string) bool <span class="cov8" title="1">{
        if f != nil </span><span class="cov8" title="1">{
                switch feature </span>{
                case "CSERunInBackground":<span class="cov8" title="1">
                        return f.EnableCSERunInBackground</span>
                case "BlockOutboundInternet":<span class="cov8" title="1">
                        return f.BlockOutboundInternet</span>
                case "EnableIPv6DualStack":<span class="cov8" title="1">
                        return f.EnableIPv6DualStack</span>
                case "EnableIPv6Only":<span class="cov0" title="0">
                        return f.EnableIPv6Only</span>
                case "EnableWinDSR":<span class="cov8" title="1">
                        return f.EnableWinDSR</span>
                default:<span class="cov8" title="1">
                        return false</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// IsValid returns true if ImageRefernce contains at least Name and ResourceGroup
func (i *ImageReference) IsValid() bool <span class="cov8" title="1">{
        return len(i.Name) &gt; 0 &amp;&amp; len(i.ResourceGroup) &gt; 0
}</span>

// IsAddonEnabled checks whether a k8s addon with name "addonName" is enabled or not based on the Enabled field of KubernetesAddon.
// If the value of Enabled is nil, the "defaultValue" is returned.
func (k *KubernetesConfig) IsAddonEnabled(addonName string) bool <span class="cov8" title="1">{
        kubeAddon := k.GetAddonByName(addonName)
        return kubeAddon.IsEnabled()
}</span>

// PrivateJumpboxProvision checks if a private cluster has jumpbox auto-provisioning
func (k *KubernetesConfig) PrivateJumpboxProvision() bool <span class="cov8" title="1">{
        if k != nil &amp;&amp; k.PrivateCluster != nil &amp;&amp; *k.PrivateCluster.Enabled &amp;&amp; k.PrivateCluster.JumpboxProfile != nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsRBACEnabled checks if RBAC is enabled
func (k *KubernetesConfig) IsRBACEnabled() bool <span class="cov0" title="0">{
        if k.EnableRbac != nil </span><span class="cov0" title="0">{
                return to.Bool(k.EnableRbac)
        }</span>
        <span class="cov0" title="0">return false</span>
}

// UserAssignedIDEnabled checks if the user assigned ID is enabled or not.
func (k *KubernetesConfig) UserAssignedIDEnabled() bool <span class="cov8" title="1">{
        return k.UseManagedIdentity &amp;&amp; k.UserAssignedID != ""
}</span>

// IsIPMasqAgentDisabled checks if the ip-masq-agent addon is disabled
func (k *KubernetesConfig) IsIPMasqAgentDisabled() bool <span class="cov8" title="1">{
        return k.IsAddonDisabled(IPMASQAgentAddonName)
}</span>

// IsIPMasqAgentEnabled checks if the ip-masq-agent addon is enabled
func (k *KubernetesConfig) IsIPMasqAgentEnabled() bool <span class="cov8" title="1">{
        return k.IsAddonEnabled(IPMASQAgentAddonName)
}</span>

// GetAddonByName returns the KubernetesAddon instance with name `addonName`
func (k *KubernetesConfig) GetAddonByName(addonName string) KubernetesAddon <span class="cov8" title="1">{
        var kubeAddon KubernetesAddon
        for _, addon := range k.Addons </span><span class="cov8" title="1">{
                if strings.EqualFold(addon.Name, addonName) </span><span class="cov8" title="1">{
                        kubeAddon = addon
                        break</span>
                }
        }
        <span class="cov8" title="1">return kubeAddon</span>
}

// IsAddonDisabled checks whether a k8s addon with name "addonName" is explicitly disabled based on the Enabled field of KubernetesAddon.
// If the value of Enabled is nil, we return false (not explicitly disabled)
func (k *KubernetesConfig) IsAddonDisabled(addonName string) bool <span class="cov8" title="1">{
        kubeAddon := k.GetAddonByName(addonName)
        return kubeAddon.IsDisabled()
}</span>

// NeedsContainerd returns whether or not we need the containerd runtime configuration
// E.g., kata configuration requires containerd config
func (k *KubernetesConfig) NeedsContainerd() bool <span class="cov8" title="1">{
        return strings.EqualFold(k.ContainerRuntime, KataContainers) || strings.EqualFold(k.ContainerRuntime, Containerd)
}</span>

// RequiresDocker returns if the kubernetes settings require docker binary to be installed.
func (k *KubernetesConfig) RequiresDocker() bool <span class="cov8" title="1">{
        if k == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return strings.EqualFold(k.ContainerRuntime, Docker) || k.ContainerRuntime == ""</span>
}

// IsAADPodIdentityEnabled checks if the AAD pod identity addon is enabled
func (k *KubernetesConfig) IsAADPodIdentityEnabled() bool <span class="cov0" title="0">{
        return k.IsAddonEnabled(AADPodIdentityAddonName)
}</span>

// GetAzureCNIURLLinux returns the full URL to source Azure CNI binaries from
func (k *KubernetesConfig) GetAzureCNIURLLinux(cloudSpecConfig *AzureEnvironmentSpecConfig) string <span class="cov0" title="0">{
        if k.AzureCNIURLLinux != "" </span><span class="cov0" title="0">{
                return k.AzureCNIURLLinux
        }</span>
        <span class="cov0" title="0">return cloudSpecConfig.KubernetesSpecConfig.VnetCNILinuxPluginsDownloadURL</span>
}

// GetAzureCNIURLARM64Linux returns the full URL to source Azure CNI binaries for ARM64 Linux from
func (k *KubernetesConfig) GetAzureCNIURLARM64Linux(cloudSpecConfig *AzureEnvironmentSpecConfig) string <span class="cov0" title="0">{
        if k.AzureCNIURLARM64Linux != "" </span><span class="cov0" title="0">{
                return k.AzureCNIURLARM64Linux
        }</span>
        <span class="cov0" title="0">return cloudSpecConfig.KubernetesSpecConfig.VnetCNIARM64LinuxPluginsDownloadURL</span>
}

// GetAzureCNIURLWindows returns the full URL to source Azure CNI binaries from
func (k *KubernetesConfig) GetAzureCNIURLWindows(cloudSpecConfig *AzureEnvironmentSpecConfig) string <span class="cov0" title="0">{
        if k.AzureCNIURLWindows != "" </span><span class="cov0" title="0">{
                return k.AzureCNIURLWindows
        }</span>
        <span class="cov0" title="0">return cloudSpecConfig.KubernetesSpecConfig.VnetCNIWindowsPluginsDownloadURL</span>
}

// IsUsingNetworkPluginMode returns true of NetworkPluginMode matches mode param
func (k *KubernetesConfig) IsUsingNetworkPluginMode(mode string) bool <span class="cov0" title="0">{
        return strings.EqualFold(k.NetworkPluginMode, mode)
}</span>

// GetOrderedKubeletConfigStringForPowershell returns an ordered string of key/val pairs for Powershell script consumption
func (config *NodeBootstrappingConfiguration) GetOrderedKubeletConfigStringForPowershell(customKc *CustomKubeletConfig) string <span class="cov8" title="1">{
        kubeletConfig := config.KubeletConfig
        if kubeletConfig == nil </span><span class="cov8" title="1">{
                kubeletConfig = map[string]string{}
        }</span>

        // override default kubelet configuration with customzied ones
        <span class="cov8" title="1">if config.ContainerService != nil &amp;&amp; config.ContainerService.Properties != nil </span><span class="cov8" title="1">{
                kubeletCustomConfiguration := config.ContainerService.Properties.GetComponentWindowsKubernetesConfiguration(Componentkubelet)
                if kubeletCustomConfiguration != nil </span><span class="cov8" title="1">{
                        config := kubeletCustomConfiguration.Config
                        for k, v := range config </span><span class="cov8" title="1">{
                                kubeletConfig[k] = v
                        }</span>
                }
        }

        // Settings from customKubeletConfig, only take if it's set
        <span class="cov8" title="1">if customKc != nil </span><span class="cov8" title="1">{
                if customKc.ImageGcHighThreshold != nil </span><span class="cov8" title="1">{
                        kubeletConfig["--image-gc-high-threshold"] = fmt.Sprintf("%d", *customKc.ImageGcHighThreshold)
                }</span>
                <span class="cov8" title="1">if customKc.ImageGcLowThreshold != nil </span><span class="cov8" title="1">{
                        kubeletConfig["--image-gc-low-threshold"] = fmt.Sprintf("%d", *customKc.ImageGcLowThreshold)
                }</span>
                <span class="cov8" title="1">if customKc.ContainerLogMaxSizeMB != nil </span><span class="cov8" title="1">{
                        kubeletConfig["--container-log-max-size"] = fmt.Sprintf("%dMi", *customKc.ContainerLogMaxSizeMB)
                }</span>
                <span class="cov8" title="1">if customKc.ContainerLogMaxFiles != nil </span><span class="cov8" title="1">{
                        kubeletConfig["--container-log-max-files"] = fmt.Sprintf("%d", *customKc.ContainerLogMaxFiles)
                }</span>
        }

        <span class="cov8" title="1">if len(kubeletConfig) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">keys := []string{}
        for key := range kubeletConfig </span><span class="cov8" title="1">{
                if !CommandLineOmittedKubeletConfigFlags[key] </span><span class="cov8" title="1">{
                        keys = append(keys, key)
                }</span>
        }

        <span class="cov8" title="1">sort.Strings(keys)
        var buf bytes.Buffer
        for _, key := range keys </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("\"%s=%s\", ", key, kubeletConfig[key]))
        }</span>
        <span class="cov8" title="1">return strings.TrimSuffix(buf.String(), ", ")</span>
}

// GetOrderedKubeproxyConfigStringForPowershell returns an ordered string of key/val pairs for Powershell script consumption
func (config *NodeBootstrappingConfiguration) GetOrderedKubeproxyConfigStringForPowershell() string <span class="cov8" title="1">{
        kubeproxyConfig := config.KubeproxyConfig
        if kubeproxyConfig == nil </span><span class="cov8" title="1">{
                // https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
                // --metrics-bind-address ipport     Default: 127.0.0.1:10249
                // The IP address with port for the metrics server to serve on (set to '0.0.0.0:10249' for all IPv4 interfaces and '[::]:10249' for all IPv6 interfaces). Set empty to disable.
                // This only works with Windows provisioning package v0.0.15+.
                // https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-provisioning-scripts-release-notes.md#v0015
                kubeproxyConfig = map[string]string{"--metrics-bind-address": "0.0.0.0:10249"}
        }</span>

        <span class="cov8" title="1">if _, ok := kubeproxyConfig["--metrics-bind-address"]; !ok </span><span class="cov8" title="1">{
                kubeproxyConfig["--metrics-bind-address"] = "0.0.0.0:10249"
        }</span>

        // override kube proxy configuration with the customzied ones.
        <span class="cov8" title="1">kubeProxyCustomConfiguration := config.ContainerService.Properties.GetComponentWindowsKubernetesConfiguration(ComponentkubeProxy)
        if kubeProxyCustomConfiguration != nil </span><span class="cov8" title="1">{
                customConfig := kubeProxyCustomConfiguration.Config
                for k, v := range customConfig </span><span class="cov8" title="1">{
                        kubeproxyConfig[k] = v
                }</span>
        }
        <span class="cov8" title="1">keys := []string{}
        for key := range kubeproxyConfig </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        var buf bytes.Buffer
        for _, key := range keys </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("\"%s=%s\", ", key, kubeproxyConfig[key]))
        }</span>
        <span class="cov8" title="1">return strings.TrimSuffix(buf.String(), ", ")</span>
}

// IsEnabled returns true if the addon is enabled
func (a *KubernetesAddon) IsEnabled() bool <span class="cov8" title="1">{
        if a.Enabled == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return *a.Enabled</span>
}

// IsDisabled returns true if the addon is explicitly disabled
func (a *KubernetesAddon) IsDisabled() bool <span class="cov8" title="1">{
        if a.Enabled == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return !*a.Enabled</span>
}

// GetAddonContainersIndexByName returns the KubernetesAddon containers index with the name `containerName`
func (a KubernetesAddon) GetAddonContainersIndexByName(containerName string) int <span class="cov8" title="1">{
        for i := range a.Containers </span><span class="cov8" title="1">{
                if strings.EqualFold(a.Containers[i].Name, containerName) </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// FormatProdFQDNByLocation constructs an Azure prod fqdn with custom cloud profile
// CustomCloudName is name of environment if customCloudProfile is provided, it will be empty string if customCloudProfile is empty.
// Because customCloudProfile is empty for deployment for AzurePublicCloud, AzureChinaCloud,AzureGermanCloud,AzureUSGovernmentCloud,
// The customCloudName value will be empty string for those clouds
func FormatProdFQDNByLocation(fqdnPrefix string, location string, cloudSpecConfig *AzureEnvironmentSpecConfig) string <span class="cov0" title="0">{
        FQDNFormat := cloudSpecConfig.EndpointConfig.ResourceManagerVMDNSSuffix
        return fmt.Sprintf("%s.%s."+FQDNFormat, fqdnPrefix, location)
}</span>

type K8sComponents struct {
        // Full path to the "pause" image. Used for --pod-infra-container-image
        // For example: "mcr.microsoft.com/oss/kubernetes/pause:1.3.1"
        PodInfraContainerImageURL string

        // Full path to the hyperkube image.
        // For example: "mcr.microsoft.com/hyperkube-amd64:v1.16.13"
        HyperkubeImageURL string

        // Full path to the Windows package (windowszip) to use.
        // For example: https://acs-mirror.azureedge.net/kubernetes/v1.17.8/windowszip/v1.17.8-1int.zip
        WindowsPackageURL string
}

// GetLatestSigImageConfigRequest describes the input for a GetLatestSigImageConfig HTTP request.
// This is mostly a wrapper over existing types so RP doesn't have to manually construct JSON.
type GetLatestSigImageConfigRequest struct {
        SIGConfig SIGConfig
        Region    string
        Distro    Distro
}

// NodeBootstrappingConfiguration represents configurations for node bootstrapping
type NodeBootstrappingConfiguration struct {
        ContainerService              *ContainerService
        CloudSpecConfig               *AzureEnvironmentSpecConfig
        K8sComponents                 *K8sComponents
        AgentPoolProfile              *AgentPoolProfile
        TenantID                      string
        SubscriptionID                string
        ResourceGroupName             string
        UserAssignedIdentityClientID  string
        OSSKU                         string
        ConfigGPUDriverIfNeeded       bool
        Disable1804SystemdResolved    bool
        EnableGPUDevicePluginIfNeeded bool
        EnableKubeletConfigFile       bool
        EnableNvidia                  bool
        EnableACRTeleportPlugin       bool
        TeleportdPluginURL            string
        ContainerdVersion             string
        RuncVersion                   string
        // ContainerdPackageURL and RuncPackageURL are beneficial for testing non-official
        // containerd and runc, like the pre-released ones.
        // Currently both configurations are for test purpose, and only deb package is supported
        ContainerdPackageURL string
        RuncPackageURL       string
        // KubeletClientTLSBootstrapToken - kubelet client TLS bootstrap token to use.
        // When this feature is enabled, we skip kubelet kubeconfig generation and replace it with bootstrap kubeconfig.
        // ref: https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping
        KubeletClientTLSBootstrapToken *string
        FIPSEnabled                    bool
        HTTPProxyConfig                *HTTPProxyConfig
        KubeletConfig                  map[string]string
        KubeproxyConfig                map[string]string
        EnableRuncShimV2               bool
        GPUInstanceProfile             string
        PrimaryScaleSetName            string
        SIGConfig                      SIGConfig
        IsARM64                        bool
        CustomCATrustConfig            *CustomCATrustConfig
        DisableUnattendedUpgrades      bool
        SSHStatus                      SSHStatus
}

type SSHStatus int

const (
        SSHUnspecified SSHStatus = iota
        SSHOff
        SSHOn
)

// NodeBootstrapping represents the custom data, CSE, and OS image info needed for node bootstrapping.
type NodeBootstrapping struct {
        CustomData     string
        CSE            string
        OSImageConfig  *AzureOSImageConfig
        SigImageConfig *SigImageConfig
}

// HTTPProxyConfig represents configurations of http proxy
type HTTPProxyConfig struct {
        HTTPProxy  *string   `json:"httpProxy,omitempty"`
        HTTPSProxy *string   `json:"httpsProxy,omitempty"`
        NoProxy    *[]string `json:"noProxy,omitempty"`
        TrustedCA  *string   `json:"trustedCa,omitempty"`
}

type CustomCATrustConfig struct {
        CustomCATrustCerts []string `json:"customCATrustCerts,omitempty"`
}

// AKSKubeletConfiguration contains the configuration for the Kubelet that AKS set
// this is a subset of KubeletConfiguration defined in https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubelet/config/v1beta1/types.go
// changed metav1.Duration to Duration and pointers to values to simplify translation
type AKSKubeletConfiguration struct {
        // Kind is a string value representing the REST resource this object represents.
        // Servers may infer this from the endpoint the client submits requests to.
        // Cannot be updated.
        // In CamelCase.
        // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        // +optional
        Kind string `json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`
        // APIVersion defines the versioned schema of this representation of an object.
        // Servers should convert recognized schemas to the latest internal value, and
        // may reject unrecognized values.
        // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        // +optional
        APIVersion string `json:"apiVersion,omitempty" protobuf:"bytes,2,opt,name=apiVersion"`
        // staticPodPath is the path to the directory containing local (static) pods to
        // run, or the path to a single static pod file.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // the set of static pods specified at the new path may be different than the
        // ones the Kubelet initially started with, and this may disrupt your node.
        // Default: ""
        // +optional
        StaticPodPath string `json:"staticPodPath,omitempty"`
        // address is the IP address for the Kubelet to serve on (set to 0.0.0.0
        // for all interfaces).
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may disrupt components that interact with the Kubelet server.
        // Default: "0.0.0.0"
        // +optional
        Address string `json:"address,omitempty"`
        // readOnlyPort is the read-only port for the Kubelet to serve on with
        // no authentication/authorization.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may disrupt components that interact with the Kubelet server.
        // Default: 0 (disabled)
        // +optional
        ReadOnlyPort int32 `json:"readOnlyPort,omitempty"`
        // tlsCertFile is the file containing x509 Certificate for HTTPS. (CA cert,
        // if any, concatenated after server cert). If tlsCertFile and
        // tlsPrivateKeyFile are not provided, a self-signed certificate
        // and key are generated for the public address and saved to the directory
        // passed to the Kubelet's --cert-dir flag.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may disrupt components that interact with the Kubelet server.
        // Default: ""
        // +optional
        TLSCertFile string `json:"tlsCertFile,omitempty"`
        // tlsPrivateKeyFile is the file containing x509 private key matching tlsCertFile
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may disrupt components that interact with the Kubelet server.
        // Default: ""
        // +optional
        TLSPrivateKeyFile string `json:"tlsPrivateKeyFile,omitempty"`
        // TLSCipherSuites is the list of allowed cipher suites for the server.
        // Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may disrupt components that interact with the Kubelet server.
        // Default: nil
        // +optional
        TLSCipherSuites []string `json:"tlsCipherSuites,omitempty"`
        // rotateCertificates enables client certificate rotation. The Kubelet will request a
        // new certificate from the certificates.k8s.io API. This requires an approver to approve the
        // certificate signing requests.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // disabling it may disrupt the Kubelet's ability to authenticate with the API server
        // after the current certificate expires.
        // Default: false
        // +optional
        RotateCertificates bool `json:"rotateCertificates,omitempty"`
        // authentication specifies how requests to the Kubelet's server are authenticated
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may disrupt components that interact with the Kubelet server.
        // Defaults:
        //   anonymous:
        //     enabled: false
        //   webhook:
        //     enabled: true
        //     cacheTTL: "2m"
        // +optional
        Authentication KubeletAuthentication `json:"authentication"`
        // authorization specifies how requests to the Kubelet's server are authorized
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may disrupt components that interact with the Kubelet server.
        // Defaults:
        //   mode: Webhook
        //   webhook:
        //     cacheAuthorizedTTL: "5m"
        //     cacheUnauthorizedTTL: "30s"
        // +optional
        Authorization KubeletAuthorization `json:"authorization"`
        // eventRecordQPS is the maximum event creations per second. If 0, there
        // is no limit enforced.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may impact scalability by changing the amount of traffic produced by
        // event creations.
        // Default: 5
        // +optional
        EventRecordQPS *int32 `json:"eventRecordQPS,omitempty"`
        // clusterDomain is the DNS domain for this cluster. If set, kubelet will
        // configure all containers to search this domain in addition to the
        // host's search domains.
        // Dynamic Kubelet Config (beta): Dynamically updating this field is not recommended,
        // as it should be kept in sync with the rest of the cluster.
        // Default: ""
        // +optional
        ClusterDomain string `json:"clusterDomain,omitempty"`
        // clusterDNS is a list of IP addresses for the cluster DNS server. If set,
        // kubelet will configure all containers to use this for DNS resolution
        // instead of the host's DNS servers.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // changes will only take effect on Pods created after the update. Draining
        // the node is recommended before changing this field.
        // Default: nil
        // +optional
        ClusterDNS []string `json:"clusterDNS,omitempty"`
        // streamingConnectionIdleTimeout is the maximum time a streaming connection
        // can be idle before the connection is automatically closed.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may impact components that rely on infrequent updates over streaming
        // connections to the Kubelet server.
        // Default: "4h"
        // +optional
        StreamingConnectionIdleTimeout Duration `json:"streamingConnectionIdleTimeout,omitempty"`
        // nodeStatusUpdateFrequency is the frequency that kubelet computes node
        // status. If node lease feature is not enabled, it is also the frequency that
        // kubelet posts node status to master.
        // Note: When node lease feature is not enabled, be cautious when changing the
        // constant, it must work with nodeMonitorGracePeriod in nodecontroller.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may impact node scalability, and also that the node controller's
        // nodeMonitorGracePeriod must be set to N*NodeStatusUpdateFrequency,
        // where N is the number of retries before the node controller marks
        // the node unhealthy.
        // Default: "10s"
        // +optional
        NodeStatusUpdateFrequency Duration `json:"nodeStatusUpdateFrequency,omitempty"`
        // nodeStatusReportFrequency is the frequency that kubelet posts node
        // status to master if node status does not change. Kubelet will ignore this
        // frequency and post node status immediately if any change is detected. It is
        // only used when node lease feature is enabled. nodeStatusReportFrequency's
        // default value is 5m. But if nodeStatusUpdateFrequency is set explicitly,
        // nodeStatusReportFrequency's default value will be set to
        // nodeStatusUpdateFrequency for backward compatibility.
        // Default: "5m"
        // +optional
        NodeStatusReportFrequency Duration `json:"nodeStatusReportFrequency,omitempty"`
        // imageGCHighThresholdPercent is the percent of disk usage after which
        // image garbage collection is always run. The percent is calculated as
        // this field value out of 100.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may trigger or delay garbage collection, and may change the image overhead
        // on the node.
        // Default: 85
        // +optional
        ImageGCHighThresholdPercent *int32 `json:"imageGCHighThresholdPercent,omitempty"`
        // imageGCLowThresholdPercent is the percent of disk usage before which
        // image garbage collection is never run. Lowest disk usage to garbage
        // collect to. The percent is calculated as this field value out of 100.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may trigger or delay garbage collection, and may change the image overhead
        // on the node.
        // Default: 80
        // +optional
        ImageGCLowThresholdPercent *int32 `json:"imageGCLowThresholdPercent,omitempty"`
        // Enable QoS based Cgroup hierarchy: top level cgroups for QoS Classes
        // And all Burstable and BestEffort pods are brought up under their
        // specific top level QoS cgroup.
        // Dynamic Kubelet Config (beta): This field should not be updated without a full node
        // reboot. It is safest to keep this value the same as the local config.
        // Default: true
        // +optional
        CgroupsPerQOS *bool `json:"cgroupsPerQOS,omitempty"`
        // CPUManagerPolicy is the name of the policy to use.
        // Requires the CPUManager feature gate to be enabled.
        // Dynamic Kubelet Config (beta): This field should not be updated without a full node
        // reboot. It is safest to keep this value the same as the local config.
        // Default: "none"
        // +optional
        CPUManagerPolicy string `json:"cpuManagerPolicy,omitempty"`
        // TopologyManagerPolicy is the name of the policy to use.
        // Policies other than "none" require the TopologyManager feature gate to be enabled.
        // Dynamic Kubelet Config (beta): This field should not be updated without a full node
        // reboot. It is safest to keep this value the same as the local config.
        // Default: "none"
        // +optional
        TopologyManagerPolicy string `json:"topologyManagerPolicy,omitempty"`
        // maxPods is the number of pods that can run on this Kubelet.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // changes may cause Pods to fail admission on Kubelet restart, and may change
        // the value reported in Node.Status.Capacity[v1.ResourcePods], thus affecting
        // future scheduling decisions. Increasing this value may also decrease performance,
        // as more Pods can be packed into a single node.
        // Default: 110
        // +optional
        MaxPods int32 `json:"maxPods,omitempty"`
        // PodPidsLimit is the maximum number of pids in any pod.
        // Requires the SupportPodPidsLimit feature gate to be enabled.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // lowering it may prevent container processes from forking after the change.
        // Default: -1
        // +optional
        PodPidsLimit *int64 `json:"podPidsLimit,omitempty"`
        // ResolverConfig is the resolver configuration file used as the basis
        // for the container DNS resolution configuration.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // changes will only take effect on Pods created after the update. Draining
        // the node is recommended before changing this field.
        // Default: "/etc/resolv.conf"
        // +optional
        ResolverConfig string `json:"resolvConf,omitempty"`
        // cpuCFSQuota enables CPU CFS quota enforcement for containers that
        // specify CPU limits.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // disabling it may reduce node stability.
        // Default: true
        // +optional
        CPUCFSQuota *bool `json:"cpuCFSQuota,omitempty"`
        // CPUCFSQuotaPeriod is the CPU CFS quota period value, cpu.cfs_period_us.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // limits set for containers will result in different cpu.cfs_quota settings. This
        // will trigger container restarts on the node being reconfigured.
        // Default: "100ms"
        // +optional
        CPUCFSQuotaPeriod Duration `json:"cpuCFSQuotaPeriod,omitempty"`
        // Map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available": "300Mi"}.
        // To explicitly disable, pass a 0% or 100% threshold on an arbitrary resource.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may trigger or delay Pod evictions.
        // Default:
        //   memory.available:  "100Mi"
        //   nodefs.available:  "10%"
        //   nodefs.inodesFree: "5%"
        //   imagefs.available: "15%"
        // +optional
        EvictionHard map[string]string `json:"evictionHard,omitempty"`
        // protectKernelDefaults, if true, causes the Kubelet to error if kernel
        // flags are not as it expects. Otherwise the Kubelet will attempt to modify
        // kernel flags to match its expectation.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // enabling it may cause the Kubelet to crash-loop if the Kernel is not configured as
        // Kubelet expects.
        // Default: false
        // +optional
        ProtectKernelDefaults bool `json:"protectKernelDefaults,omitempty"`
        // featureGates is a map of feature names to bools that enable or disable alpha/experimental
        // features. This field modifies piecemeal the built-in default values from
        // "k8s.io/kubernetes/pkg/features/kube_features.go".
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider the
        // documentation for the features you are enabling or disabling. While we
        // encourage feature developers to make it possible to dynamically enable
        // and disable features, some changes may require node reboots, and some
        // features may require careful coordination to retroactively disable.
        // Default: nil
        // +optional
        FeatureGates map[string]bool `json:"featureGates,omitempty"`
        // failSwapOn tells the Kubelet to fail to start if swap is enabled on the node.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // setting it to true will cause the Kubelet to crash-loop if swap is enabled.
        // Default: true
        // +optional
        FailSwapOn *bool `json:"failSwapOn,omitempty"`
        // A quantity defines the maximum size of the container log file before it is rotated.
        // For example: "5Mi" or "256Ki".
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may trigger log rotation.
        // Default: "10Mi"
        // +optional
        ContainerLogMaxSize string `json:"containerLogMaxSize,omitempty"`
        // Maximum number of container log files that can be present for a container.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // lowering it may cause log files to be deleted.
        // Default: 5
        // +optional
        ContainerLogMaxFiles *int32 `json:"containerLogMaxFiles,omitempty"`

        /* the following fields are meant for Node Allocatable */

        // systemReserved is a set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G)
        // pairs that describe resources reserved for non-kubernetes components.
        // Currently only cpu and memory are supported.
        // See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may not be possible to increase the reserved resources, because this
        // requires resizing cgroups. Always look for a NodeAllocatableEnforced event
        // after updating this field to ensure that the update was successful.
        // Default: nil
        // +optional
        SystemReserved map[string]string `json:"systemReserved,omitempty"`
        // A set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs
        // that describe resources reserved for kubernetes system components.
        // Currently cpu, memory and local storage for root file system are supported.
        // See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // it may not be possible to increase the reserved resources, because this
        // requires resizing cgroups. Always look for a NodeAllocatableEnforced event
        // after updating this field to ensure that the update was successful.
        // Default: nil
        // +optional
        KubeReserved map[string]string `json:"kubeReserved,omitempty"`
        // This flag specifies the various Node Allocatable enforcements that Kubelet needs to perform.
        // This flag accepts a list of options. Acceptable options are `none`, `pods`, `system-reserved` &amp; `kube-reserved`.
        // If `none` is specified, no other options may be specified.
        // Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
        // Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
        // removing enforcements may reduce the stability of the node. Alternatively, adding
        // enforcements may reduce the stability of components which were using more than
        // the reserved amount of resources; for example, enforcing kube-reserved may cause
        // Kubelets to OOM if it uses more than the reserved resources, and enforcing system-reserved
        // may cause system daemons to OOM if they use more than the reserved resources.
        // Default: ["pods"]
        // +optional
        EnforceNodeAllocatable []string `json:"enforceNodeAllocatable,omitempty"`
        // A comma separated whitelist of unsafe sysctls or sysctl patterns (ending in *).
        // Unsafe sysctl groups are kernel.shm*, kernel.msg*, kernel.sem, fs.mqueue.*, and net.*.
        // These sysctls are namespaced but not allowed by default.  For example: "kernel.msg*,net.ipv4.route.min_pmtu"
        // Default: []
        // +optional
        AllowedUnsafeSysctls []string `json:"allowedUnsafeSysctls,omitempty"`
}

type Duration string

// below are copied from Kubernetes
type KubeletAuthentication struct {
        // x509 contains settings related to x509 client certificate authentication
        // +optional
        X509 KubeletX509Authentication `json:"x509"`
        // webhook contains settings related to webhook bearer token authentication
        // +optional
        Webhook KubeletWebhookAuthentication `json:"webhook"`
        // anonymous contains settings related to anonymous authentication
        // +optional
        Anonymous KubeletAnonymousAuthentication `json:"anonymous"`
}

type KubeletX509Authentication struct {
        // clientCAFile is the path to a PEM-encoded certificate bundle. If set, any request presenting a client certificate
        // signed by one of the authorities in the bundle is authenticated with a username corresponding to the CommonName,
        // and groups corresponding to the Organization in the client certificate.
        // +optional
        ClientCAFile string `json:"clientCAFile,omitempty"`
}

type KubeletWebhookAuthentication struct {
        // enabled allows bearer token authentication backed by the tokenreviews.authentication.k8s.io API
        // +optional
        Enabled bool `json:"enabled,omitempty"`
        // cacheTTL enables caching of authentication results
        // +optional
        CacheTTL Duration `json:"cacheTTL,omitempty"`
}

type KubeletAnonymousAuthentication struct {
        // enabled allows anonymous requests to the kubelet server.
        // Requests that are not rejected by another authentication method are treated as anonymous requests.
        // Anonymous requests have a username of system:anonymous, and a group name of system:unauthenticated.
        // +optional
        Enabled bool `json:"enabled,omitempty"`
}

type KubeletAuthorization struct {
        // mode is the authorization mode to apply to requests to the kubelet server.
        // Valid values are AlwaysAllow and Webhook.
        // Webhook mode uses the SubjectAccessReview API to determine authorization.
        // +optional
        Mode KubeletAuthorizationMode `json:"mode,omitempty"`

        // webhook contains settings related to Webhook authorization.
        // +optional
        Webhook KubeletWebhookAuthorization `json:"webhook"`
}

type KubeletAuthorizationMode string

type KubeletWebhookAuthorization struct {
        // cacheAuthorizedTTL is the duration to cache 'authorized' responses from the webhook authorizer.
        // +optional
        CacheAuthorizedTTL Duration `json:"cacheAuthorizedTTL,omitempty"`
        // cacheUnauthorizedTTL is the duration to cache 'unauthorized' responses from the webhook authorizer.
        // +optional
        CacheUnauthorizedTTL Duration `json:"cacheUnauthorizedTTL,omitempty"`
}

type CSEStatus struct {
        // ExitCode stores the exitCode from CSE output.
        ExitCode string `json:"exitCode,omitempty"`
        // Output stores the output from CSE output.
        Output string `json:"output,omitempty"`
        // Error stores the error from CSE output.
        Error string `json:"error,omitempty"`
        // ExecDuration stores the execDuration in seconds from CSE output.
        ExecDuration string `json:"execDuration,omitempty"`
        // KernelStartTime of current boot, output from systemctl show -p KernelTimestamp
        KernelStartTime string `json:"kernelStartTime,omitempty"`
        // SystemdSummary of current boot, output from systemd-analyze
        SystemdSummary string `json:"systemdSummary,omitempty"`
        // CSEStartTime indicate starttime of CSE
        CSEStartTime string `json:"cseStartTime,omitempty"`
        // GuestAgentStartTime indicate starttime of GuestAgent, output from systemctl show walinuxagent.service -p ExecMainStartTimestamp
        GuestAgentStartTime string `json:"guestAgentStartTime,omitempty"`
        // BootDatapoints contains datapoints (key-value pair) from VM boot process.
        BootDatapoints map[string]string `json:"bootDatapoints,omitempty"`
}

type CSEStatusParsingErrorCode string

const (
        // CSEMessageUnmarshalError is the error code for unmarshal cse message
        CSEMessageUnmarshalError CSEStatusParsingErrorCode = "CSEMessageUnmarshalError"
        // CSEMessageExitCodeEmptyError is the error code for empty cse message exit code
        CSEMessageExitCodeEmptyError CSEStatusParsingErrorCode = "CSEMessageExitCodeEmptyError"
        // InvalidCSEMessage is the error code for cse invalid message
        InvalidCSEMessage CSEStatusParsingErrorCode = "InvalidCSEMessage"
)

type CSEStatusParsingError struct {
        Code    CSEStatusParsingErrorCode
        Message string
}

func NewError(code CSEStatusParsingErrorCode, message string) *CSEStatusParsingError <span class="cov0" title="0">{
        return &amp;CSEStatusParsingError{Code: code, Message: message}
}</span>

func (err *CSEStatusParsingError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("CSE has invalid message=%q, InstanceErrorCode=%s", err.Message, err.Code)
}</span>

type AgentPoolWindowsProfile struct {
        DisableOutboundNat *bool `json:"disableOutboundNat,omitempty"`
}

// IsDisableWindowsOutboundNat returns true if the Windows agent pool disable OutboundNAT
func (ap *AgentPoolProfile) IsDisableWindowsOutboundNat() bool <span class="cov0" title="0">{
        return ap.AgentPoolWindowsProfile != nil &amp;&amp;
                ap.AgentPoolWindowsProfile.DisableOutboundNat != nil &amp;&amp;
                *ap.AgentPoolWindowsProfile.DisableOutboundNat
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package datamodel

import (
        "fmt"
        "sort"
        "strings"

        "github.com/blang/semver"
        "github.com/pkg/errors"
)

// AllKubernetesSupportedVersions is a whitelist map of all supported Kubernetes version strings
// The bool value indicates if creating new clusters with this version is allowed
var AllKubernetesSupportedVersions = map[string]bool{
        "1.6.6":          false,
        "1.6.9":          true, // need to keep 1.6.9 version support for v20160930
        "1.6.11":         false,
        "1.6.12":         false,
        "1.6.13":         false,
        "1.7.0":          false,
        "1.7.1":          false,
        "1.7.2":          false,
        "1.7.4":          false,
        "1.7.5":          false,
        "1.7.7":          false,
        "1.7.9":          false,
        "1.7.10":         false,
        "1.7.12":         false,
        "1.7.13":         false,
        "1.7.14":         false,
        "1.7.15":         false,
        "1.7.16":         false,
        "1.8.0":          false,
        "1.8.1":          false,
        "1.8.2":          false,
        "1.8.4":          false,
        "1.8.6":          false,
        "1.8.7":          false,
        "1.8.8":          false,
        "1.8.9":          false,
        "1.8.10":         false,
        "1.8.11":         false,
        "1.8.12":         false,
        "1.8.13":         false,
        "1.8.14":         false,
        "1.8.15":         false,
        "1.9.0":          false,
        "1.9.1":          false,
        "1.9.2":          false,
        "1.9.3":          false,
        "1.9.4":          false,
        "1.9.5":          false,
        "1.9.6":          false,
        "1.9.7":          false,
        "1.9.8":          false,
        "1.9.9":          false,
        "1.9.10":         false,
        "1.9.11":         false,
        "1.10.0-beta.2":  false,
        "1.10.0-beta.4":  false,
        "1.10.0-rc.1":    false,
        "1.10.0":         false,
        "1.10.1":         false,
        "1.10.2":         false,
        "1.10.3":         false,
        "1.10.4":         false,
        "1.10.5":         false,
        "1.10.6":         false,
        "1.10.7":         false,
        "1.10.8":         false,
        "1.10.9":         false,
        "1.10.12":        false,
        "1.10.13":        false,
        "1.11.0-alpha.1": false,
        "1.11.0-alpha.2": false,
        "1.11.0-beta.1":  false,
        "1.11.0-beta.2":  false,
        "1.11.0-rc.1":    false,
        "1.11.0-rc.2":    false,
        "1.11.0-rc.3":    false,
        "1.11.0":         false,
        "1.11.1":         false,
        "1.11.2":         false,
        "1.11.3":         false,
        "1.11.4":         false,
        "1.11.5":         false,
        "1.11.6":         false,
        "1.11.7":         false,
        "1.11.8":         false,
        "1.11.9":         false,
        "1.11.10":        false,
        "1.12.0-alpha.1": false,
        "1.12.0-beta.0":  false,
        "1.12.0-beta.1":  false,
        "1.12.0-rc.1":    false,
        "1.12.0-rc.2":    false,
        "1.12.0":         false,
        "1.12.1":         false,
        "1.12.2":         false,
        "1.12.4":         false,
        "1.12.5":         false,
        "1.12.6":         false,
        "1.12.7":         false,
        "1.12.8":         false,
        "1.12.9":         false, // disabled because of https://github.com/Azure/aks-engine/issues/1421
        "1.13.0-alpha.1": false,
        "1.13.0-alpha.2": false,
        "1.13.1":         false,
        "1.13.2":         false,
        "1.13.3":         false,
        "1.13.4":         false,
        "1.13.5":         false,
        "1.13.6":         false, // disabled because of https://github.com/kubernetes/kubernetes/issues/78308
        "1.13.7":         false,
        "1.13.8":         false,
        "1.13.9":         false,
        "1.13.10":        false,
        "1.13.11":        true,
        "1.13.12":        true, // disabled because of https://github.com/Azure/aks-engine/issues/2312, enabled for aks with v1.13.12_f0.0.2
        "1.14.0-alpha.1": false,
        "1.14.0-alpha.2": false,
        "1.14.0-beta.1":  false,
        "1.14.0-beta.2":  false,
        "1.14.0-rc.1":    false,
        "1.14.0":         false,
        "1.14.1":         false,
        "1.14.2":         false, // disabled because of https://github.com/kubernetes/kubernetes/issues/78308
        "1.14.3":         false,
        "1.14.4":         false,
        "1.14.5":         false,
        "1.14.6":         false,
        "1.14.7":         true,
        "1.14.8":         true,  // disabled because of https://github.com/Azure/aks-engine/issues/2312, enabled for aks with v1.14.8_f0.0.4
        "1.14.10":        false, // disabled because of https://github.com/Azure/aks-engine/issues/2312
        "1.15.0-alpha.1": false,
        "1.15.0-alpha.2": false,
        "1.15.0-alpha.3": false,
        "1.15.0-beta.1":  false,
        "1.15.0-beta.2":  false,
        "1.15.0-rc.1":    false,
        "1.15.0":         false,
        "1.15.1":         false,
        "1.15.2":         false,
        "1.15.3":         false,
        "1.15.4":         false,
        "1.15.5":         false, // disabled because of https://github.com/Azure/aks-engine/issues/2312
        "1.15.7":         true,  // enabled for aks with v1.15.7_f0.0.2
        "1.15.8":         false, // disabled because of https://github.com/kubernetes/release/issues/1020
        "1.15.9":         true,
        "1.15.10":        true,
        "1.15.11":        true,
        "1.15.12":        true,
        "1.16.0-alpha.1": false,
        "1.16.0-alpha.2": false,
        "1.16.0-alpha.3": false,
        "1.16.0-beta.1":  false,
        "1.16.0-beta.2":  false,
        "1.16.0-rc.1":    false,
        "1.16.0":         false,
        "1.16.1":         false,
        "1.16.2":         false, // disabled because of https://github.com/Azure/aks-engine/issues/2312
        "1.16.4":         false,
        "1.16.5":         false, // disabled because of https://github.com/kubernetes/release/issues/1020
        "1.16.6":         true,
        "1.16.7":         true,
        "1.16.8":         false,
        "1.16.9":         true,
        "1.16.10":        true,
        "1.16.13":        true,
        "1.16.15":        true,
        "1.17.0-alpha.1": false,
        "1.17.0-alpha.2": false,
        "1.17.0-alpha.3": false,
        "1.17.0-beta.1":  false,
        "1.17.0-beta.2":  false,
        "1.17.0-rc.1":    false,
        "1.17.0-rc.2":    false,
        "1.17.0":         false,
        "1.17.1":         false,
        "1.17.2":         true,
        "1.17.3":         true,
        "1.17.4":         true,
        "1.17.5":         true,
        "1.17.6":         false,
        "1.17.7":         true,
        "1.17.9":         true,
        "1.17.11":        true,
        "1.18.0":         false,
        "1.18.1":         true,
        "1.18.2":         true,
        "1.18.3":         false,
        "1.18.4":         true,
        "1.18.6":         true,
        "1.19.0":         true,
}

// GetDefaultKubernetesVersion returns the default Kubernetes version, that is the latest patch of the default release
func GetDefaultKubernetesVersion(hasWindows bool) string <span class="cov8" title="1">{
        defaultRelease := KubernetesDefaultRelease
        if hasWindows </span><span class="cov8" title="1">{
                defaultRelease = KubernetesDefaultReleaseWindows
        }</span>
        <span class="cov8" title="1">return GetLatestPatchVersion(defaultRelease, GetAllSupportedKubernetesVersions(false, hasWindows))</span>
}

// GetSupportedKubernetesVersion verifies that a passed-in version string is supported, or returns a default version string if not
func GetSupportedKubernetesVersion(version string, hasWindows bool) string <span class="cov8" title="1">{
        k8sVersion := GetDefaultKubernetesVersion(hasWindows)
        if hasWindows </span><span class="cov8" title="1">{
                if AllKubernetesWindowsSupportedVersions[version] </span><span class="cov8" title="1">{
                        k8sVersion = version
                }</span>
        } else<span class="cov8" title="1"> {
                if AllKubernetesSupportedVersions[version] </span><span class="cov8" title="1">{
                        k8sVersion = version
                }</span>
        }
        <span class="cov8" title="1">return k8sVersion</span>
}

// GetAllSupportedKubernetesVersions returns a slice of all supported Kubernetes versions
func GetAllSupportedKubernetesVersions(isUpdate, hasWindows bool) []string <span class="cov8" title="1">{
        var versions []string
        allSupportedVersions := AllKubernetesSupportedVersions
        if hasWindows </span><span class="cov8" title="1">{
                allSupportedVersions = AllKubernetesWindowsSupportedVersions
        }</span>
        <span class="cov8" title="1">for ver, supported := range allSupportedVersions </span><span class="cov8" title="1">{
                if isUpdate || supported </span><span class="cov8" title="1">{
                        versions = append(versions, ver)
                }</span>
        }
        <span class="cov8" title="1">sort.Slice(versions, func(i, j int) bool </span><span class="cov8" title="1">{
                return IsKubernetesVersionGe(versions[j], versions[i])
        }</span>)
        <span class="cov8" title="1">return versions</span>
}

// GetVersionsGt returns a list of versions greater than a semver string given a list of versions
// inclusive=true means that we test for equality as well
// preReleases=true means that we include pre-release versions in the list
func GetVersionsGt(versions []string, version string, inclusive, preReleases bool) []string <span class="cov8" title="1">{
        // Try to get latest version matching the release
        var ret []string
        minVersion, _ := semver.Make(version)
        for _, v := range versions </span><span class="cov8" title="1">{
                sv, _ := semver.Make(v)
                if !preReleases &amp;&amp; len(sv.Pre) != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if (inclusive &amp;&amp; sv.GTE(minVersion)) || (!inclusive &amp;&amp; sv.GT(minVersion)) </span><span class="cov8" title="1">{
                        ret = append(ret, v)
                }</span>
        }
        <span class="cov8" title="1">return ret</span>
}

// GetVersionsLt returns a list of versions less than than a semver string given a list of versions
// inclusive=true means that we test for equality as well
// preReleases=true means that we include pre-release versions in the list
func GetVersionsLt(versions []string, version string, inclusive, preReleases bool) []string <span class="cov8" title="1">{
        // Try to get latest version matching the release
        var ret []string
        minVersion, _ := semver.Make(version)
        for _, v := range versions </span><span class="cov8" title="1">{
                sv, _ := semver.Make(v)
                if !preReleases &amp;&amp; len(sv.Pre) != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if (inclusive &amp;&amp; sv.LTE(minVersion)) || (!inclusive &amp;&amp; sv.LT(minVersion)) </span><span class="cov8" title="1">{
                        ret = append(ret, v)
                }</span>
        }
        <span class="cov8" title="1">return ret</span>
}

// GetVersionsBetween returns a list of versions between a min and max
// inclusive=true means that we test for equality on both bounds
// preReleases=true means that we include pre-release versions in the list
func GetVersionsBetween(versions []string, versionMin, versionMax string, inclusive, preReleases bool) []string <span class="cov8" title="1">{
        var ret []string
        if minV, _ := semver.Make(versionMin); len(minV.Pre) != 0 </span><span class="cov8" title="1">{
                preReleases = true
        }</span>
        <span class="cov8" title="1">greaterThan := GetVersionsGt(versions, versionMin, inclusive, preReleases)
        lessThan := GetVersionsLt(versions, versionMax, inclusive, preReleases)
        for _, lv := range lessThan </span><span class="cov8" title="1">{
                for _, gv := range greaterThan </span><span class="cov8" title="1">{
                        if lv == gv </span><span class="cov8" title="1">{
                                ret = append(ret, lv)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

// GetMinVersion gets the lowest semver version
// preRelease=true means accept a pre-release version as a min value
func GetMinVersion(versions []string, preRelease bool) string <span class="cov8" title="1">{
        if len(versions) &lt; 1 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">semverVersions := getSortedSemverVersions(versions, preRelease)
        return semverVersions[0].String()</span>
}

// GetMaxVersion gets the highest semver version
// preRelease=true means accept a pre-release version as a max value
func GetMaxVersion(versions []string, preRelease bool) string <span class="cov8" title="1">{
        if len(versions) &lt; 1 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">semverVersions := getSortedSemverVersions(versions, preRelease)
        return semverVersions[len(semverVersions)-1].String()</span>
}

func getSortedSemverVersions(versions []string, preRelease bool) []semver.Version <span class="cov8" title="1">{
        var semverVersions []semver.Version
        for _, v := range versions </span><span class="cov8" title="1">{
                sv, _ := semver.Make(v)
                if len(sv.Pre) == 0 || preRelease </span><span class="cov8" title="1">{
                        semverVersions = append(semverVersions, sv)
                }</span>
        }
        <span class="cov8" title="1">semver.Sort(semverVersions)
        return semverVersions</span>
}

// AllKubernetesWindowsSupportedVersions maintain a set of available k8s Windows versions in aks-engine
var AllKubernetesWindowsSupportedVersions = getAllKubernetesWindowsSupportedVersionsMap()

func getAllKubernetesWindowsSupportedVersionsMap() map[string]bool <span class="cov8" title="1">{
        ret := make(map[string]bool)
        for k, v := range AllKubernetesSupportedVersions </span><span class="cov8" title="1">{
                ret[k] = v
        }</span>
        <span class="cov8" title="1">for _, version := range []string{
                "1.6.6",
                "1.6.9",
                "1.6.11",
                "1.6.12",
                "1.6.13",
                "1.7.0",
                "1.7.1",
                "1.8.13",
                "1.8.14",
                "1.8.15",
                "1.10.0-beta.2",
                "1.10.0-beta.4",
                "1.10.0-rc.1",
                "1.11.0-alpha.1",
                "1.11.0-alpha.2"} </span><span class="cov8" title="1">{
                delete(ret, version)
        }</span>
        // 1.8.12 is the latest supported patch for Windows
        <span class="cov8" title="1">ret["1.8.12"] = true
        return ret</span>
}

// GetSupportedVersions get supported version list for a certain orchestrator
func GetSupportedVersions(orchType string, isUpdate, hasWindows bool) (versions []string, defaultVersion string) <span class="cov8" title="1">{
        switch orchType </span>{
        case Kubernetes:<span class="cov8" title="1">
                return GetAllSupportedKubernetesVersions(isUpdate, hasWindows), GetDefaultKubernetesVersion(hasWindows)</span>
        default:<span class="cov0" title="0">
                return nil, ""</span>
        }
}

//GetValidPatchVersion gets the current valid patch version for the minor version of the passed in version
func GetValidPatchVersion(orchType, orchVer string, isUpdate, hasWindows bool) string <span class="cov8" title="1">{
        if orchVer == "" </span><span class="cov8" title="1">{
                return RationalizeReleaseAndVersion(
                        orchType,
                        "",
                        "",
                        isUpdate,
                        hasWindows)
        }</span>

        // check if the current version is valid, this allows us to have multiple supported patch versions in the future if we need it
        <span class="cov8" title="1">version := RationalizeReleaseAndVersion(
                orchType,
                "",
                orchVer,
                isUpdate,
                hasWindows)

        if version == "" </span><span class="cov0" title="0">{
                sv, err := semver.Make(orchVer)
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">sr := fmt.Sprintf("%d.%d", sv.Major, sv.Minor)

                version = RationalizeReleaseAndVersion(
                        orchType,
                        sr,
                        "",
                        isUpdate,
                        hasWindows)</span>
        }
        <span class="cov8" title="1">return version</span>
}

// RationalizeReleaseAndVersion return a version when it can be rationalized from the input, otherwise ""
func RationalizeReleaseAndVersion(orchType, orchRel, orchVer string, isUpdate, hasWindows bool) (version string) <span class="cov8" title="1">{
        // ignore "v" prefix in orchestrator version and release: "v1.8.0" is equivalent to "1.8.0", "v1.9" is equivalent to "1.9"
        orchVer = strings.TrimPrefix(orchVer, "v")
        orchRel = strings.TrimPrefix(orchRel, "v")
        supportedVersions, defaultVersion := GetSupportedVersions(orchType, isUpdate, hasWindows)
        if supportedVersions == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if orchRel == "" &amp;&amp; orchVer == "" </span><span class="cov8" title="1">{
                return defaultVersion
        }</span>

        <span class="cov8" title="1">if orchVer == "" </span><span class="cov8" title="1">{
                // Try to get latest version matching the release
                version = GetLatestPatchVersion(orchRel, supportedVersions)
                return version
        }</span> else<span class="cov8" title="1"> if orchRel == "" </span><span class="cov8" title="1">{
                // Try to get version the same with orchVer
                version = ""
                for _, ver := range supportedVersions </span><span class="cov8" title="1">{
                        if ver == orchVer </span><span class="cov8" title="1">{
                                version = ver
                                break</span>
                        }
                }
                <span class="cov8" title="1">return version</span>
        }
        // Try to get latest version matching the release
        <span class="cov8" title="1">version = ""
        for _, ver := range supportedVersions </span><span class="cov8" title="1">{
                sv, _ := semver.Make(ver)
                sr := fmt.Sprintf("%d.%d", sv.Major, sv.Minor)
                if sr == orchRel &amp;&amp; ver == orchVer </span><span class="cov8" title="1">{
                        version = ver
                        break</span>
                }
        }
        <span class="cov8" title="1">return version</span>
}

func IsValidMinVersion(orchType, orchRelease, orchVersion, minVersion string) (bool, error) <span class="cov8" title="1">{
        version := RationalizeReleaseAndVersion(
                orchType,
                orchRelease,
                orchVersion,
                false,
                false)
        if version == "" </span><span class="cov8" title="1">{
                return false, errors.Errorf("the following user supplied OrchestratorProfile configuration is not supported: OrchestratorType: %s, OrchestratorRelease: %s, OrchestratorVersion: %s. Please check supported Release or Version for this build of aks-engine",
                        orchType,
                        orchRelease,
                        orchVersion)
        }</span>
        <span class="cov8" title="1">sv, err := semver.Make(version)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Errorf("could not validate version %s", version)
        }</span>
        <span class="cov8" title="1">m, err := semver.Make(minVersion)
        if err != nil </span><span class="cov8" title="1">{
                return false, errors.New("could not validate version")
        }</span>
        <span class="cov8" title="1">if sv.LT(m) </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// IsKubernetesVersionGe returns true if actualVersion is greater than or equal to version
func IsKubernetesVersionGe(actualVersion, version string) bool <span class="cov8" title="1">{
        v1, _ := semver.Make(actualVersion)
        v2, _ := semver.Make(version)
        return v1.GE(v2)
}</span>

// GetLatestPatchVersion gets the most recent patch version from a list of semver versions given a major.minor string
func GetLatestPatchVersion(majorMinor string, versionsList []string) (version string) <span class="cov8" title="1">{
        // Try to get latest version matching the release
        version = ""
        for _, ver := range versionsList </span><span class="cov8" title="1">{
                sv, err := semver.Make(ver)
                if err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">sr := fmt.Sprintf("%d.%d", sv.Major, sv.Minor)
                if sr == majorMinor </span><span class="cov8" title="1">{
                        if version == "" </span><span class="cov8" title="1">{
                                version = ver
                        }</span> else<span class="cov8" title="1"> {
                                current, _ := semver.Make(version)
                                if sv.GT(current) </span><span class="cov8" title="1">{
                                        version = ver
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return version</span>
}

// IsSupportedKubernetesVersion return true if the provided Kubernetes version is supported
func IsSupportedKubernetesVersion(version string, isUpdate, hasWindows bool) bool <span class="cov8" title="1">{
        for _, ver := range GetAllSupportedKubernetesVersions(isUpdate, hasWindows) </span><span class="cov8" title="1">{
                if ver == version </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">//"copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package agent

import (
        "encoding/base64"
        "strconv"
        "strings"

        "github.com/Azure/agentbaker/pkg/agent/datamodel"
)

func getParameters(config *datamodel.NodeBootstrappingConfiguration, generatorCode string, bakerVersion string) paramsMap <span class="cov8" title="1">{
        cs := config.ContainerService
        profile := config.AgentPoolProfile
        properties := cs.Properties
        parametersMap := paramsMap{}
        cloudSpecConfig := config.CloudSpecConfig

        linuxProfile := properties.LinuxProfile
        if linuxProfile != nil </span><span class="cov8" title="1">{
                addValue(parametersMap, "linuxAdminUsername", linuxProfile.AdminUsername)
        }</span>
        // masterEndpointDNSNamePrefix is the basis for storage account creation across dcos, swarm, and k8s
        // looks like masterEndpointDNSNamePrefix is only used in windows cse kubeconfig cluster/context name and it's not
        // required since linux uses static value for that.
        <span class="cov8" title="1">if properties.HostedMasterProfile != nil </span><span class="cov8" title="1">{
                // Agents only, use cluster DNS prefix
                if properties.HostedMasterProfile.DNSPrefix != "" </span><span class="cov8" title="1">{
                        addValue(parametersMap, "masterEndpointDNSNamePrefix", properties.HostedMasterProfile.DNSPrefix)
                }</span> else<span class="cov0" title="0"> if properties.HostedMasterProfile.FQDNSubdomain != "" </span><span class="cov0" title="0">{
                        addValue(parametersMap, "masterEndpointDNSNamePrefix", properties.HostedMasterProfile.FQDNSubdomain)
                }</span> else<span class="cov0" title="0"> {
                        // should not happen but just in case, we fill in value "localcluster" just like linux
                        addValue(parametersMap, "masterEndpointDNSNamePrefix", "localcluster")
                }</span>

        }
        <span class="cov8" title="1">if properties.HostedMasterProfile != nil </span><span class="cov8" title="1">{
                addValue(parametersMap, "vnetCidr", DefaultVNETCIDR)
        }</span>

        // Kubernetes Parameters
        <span class="cov8" title="1">if properties.OrchestratorProfile.IsKubernetes() </span><span class="cov8" title="1">{
                assignKubernetesParameters(properties, parametersMap, cloudSpecConfig, config.K8sComponents, generatorCode, config)
                if profile != nil </span><span class="cov8" title="1">{
                        assignKubernetesParametersFromAgentProfile(profile, parametersMap, cloudSpecConfig, generatorCode, config)
                }</span>
        }

        // Agent parameters
        <span class="cov8" title="1">isSetVnetCidrs := false
        for _, agentProfile := range properties.AgentPoolProfiles </span><span class="cov8" title="1">{
                if !isSetVnetCidrs &amp;&amp; len(agentProfile.VnetCidrs) != 0 </span><span class="cov8" title="1">{
                        // For AKS (properties.HostedMasterProfile != nil), set vnetCidr if a custom vnet is used so the address space can be
                        // added into the ExceptionList of Windows nodes. Otherwise, the default value `10.0.0.0/8` will
                        // be added into the ExceptionList and it does not work if users use other ip address ranges.
                        // All agent pools in the same cluster share a same VnetCidrs so we only need to set the first non-empty VnetCidrs.
                        addValue(parametersMap, "vnetCidr", strings.Join(agentProfile.VnetCidrs, ","))
                        isSetVnetCidrs = true
                }</span>
        }

        <span class="cov8" title="1">if properties.CustomConfiguration != nil &amp;&amp; properties.CustomConfiguration.KubernetesConfigurations != nil </span><span class="cov0" title="0">{
                if configuration, ok := properties.CustomConfiguration.KubernetesConfigurations["kubelet"]; ok &amp;&amp; configuration.DownloadURL != nil </span><span class="cov0" title="0">{
                        addValue(parametersMap, "customKubeBinaryURL", configuration.DownloadURL)
                }</span>
        }

        // Windows parameters
        <span class="cov8" title="1">if properties.HasWindows() </span><span class="cov8" title="1">{
                addValue(parametersMap, "windowsDockerVersion", properties.WindowsProfile.GetWindowsDockerVersion())
                addValue(parametersMap, "defaultContainerdWindowsSandboxIsolation", properties.WindowsProfile.GetDefaultContainerdWindowsSandboxIsolation())
                addValue(parametersMap, "containerdWindowsRuntimeHandlers", properties.WindowsProfile.GetContainerdWindowsRuntimeHandlers())
        }</span>

        <span class="cov8" title="1">return parametersMap</span>
}

func assignKubernetesParametersFromAgentProfile(profile *datamodel.AgentPoolProfile, parametersMap paramsMap,
        cloudSpecConfig *datamodel.AzureEnvironmentSpecConfig, generatorCode string, config *datamodel.NodeBootstrappingConfiguration) <span class="cov8" title="1">{
        if config.RuncVersion != "" </span><span class="cov8" title="1">{
                addValue(parametersMap, "runcVersion", config.RuncVersion)
        }</span>
        <span class="cov8" title="1">addValue(parametersMap, "runcPackageURL", config.RuncPackageURL)
        if profile.KubernetesConfig != nil &amp;&amp; profile.KubernetesConfig.ContainerRuntime != "" </span><span class="cov8" title="1">{
                // override containerRuntime parameter value if specified in AgentPoolProfile
                // this allows for heteregenous clusters
                addValue(parametersMap, "containerRuntime", profile.KubernetesConfig.ContainerRuntime)
                if profile.KubernetesConfig.ContainerRuntime == "containerd" </span><span class="cov8" title="1">{
                        addValue(parametersMap, "cliTool", "ctr")
                        if config.ContainerdVersion != "" </span><span class="cov8" title="1">{
                                addValue(parametersMap, "containerdVersion", config.ContainerdVersion)
                        }</span>
                        <span class="cov8" title="1">if config.TeleportdPluginURL != "" </span><span class="cov8" title="1">{
                                addValue(parametersMap, "teleportdPluginURL", config.TeleportdPluginURL)
                        }</span>
                        <span class="cov8" title="1">addValue(parametersMap, "containerdPackageURL", config.ContainerdPackageURL)</span>
                } else<span class="cov8" title="1"> {
                        addValue(parametersMap, "cliTool", "docker")
                }</span>
        }
}

func assignKubernetesParameters(properties *datamodel.Properties, parametersMap paramsMap,
        cloudSpecConfig *datamodel.AzureEnvironmentSpecConfig,
        k8sComponents *datamodel.K8sComponents,
        generatorCode string,
        config *datamodel.NodeBootstrappingConfiguration) <span class="cov8" title="1">{
        orchestratorProfile := properties.OrchestratorProfile

        if orchestratorProfile.IsKubernetes() </span><span class="cov8" title="1">{
                k8sVersion := orchestratorProfile.OrchestratorVersion
                addValue(parametersMap, "kubernetesVersion", k8sVersion)

                kubernetesConfig := orchestratorProfile.KubernetesConfig

                if kubernetesConfig != nil </span><span class="cov8" title="1">{
                        if kubernetesConfig.CustomKubeProxyImage != "" </span><span class="cov8" title="1">{
                                // kubernetesConfig.CustomKubeProxyImage is ap level property, AKS default CustomKubeProxyImage
                                // is 'multi-arch', no need to differentiate amd64/arm64 ap
                                addValue(parametersMap, "kubeProxySpec", kubernetesConfig.CustomKubeProxyImage)
                        }</span>

                        <span class="cov8" title="1">if kubernetesConfig.CustomKubeBinaryURL != "" </span><span class="cov8" title="1">{
                                // kubernetesConfig.CustomKubeBinaryURL is ap level property, CustomKubeBinaryURL is
                                // set to different for amd64/arm64 ap in RP side.
                                addValue(parametersMap, "kubeBinaryURL", kubernetesConfig.CustomKubeBinaryURL)
                        }</span>

                        <span class="cov8" title="1">addValue(parametersMap, "kubernetesHyperkubeSpec", k8sComponents.HyperkubeImageURL)

                        addValue(parametersMap, "kubeDNSServiceIP", kubernetesConfig.DNSServiceIP)
                        addValue(parametersMap, "cloudproviderConfig", paramsMap{
                                "cloudProviderBackoffMode":          kubernetesConfig.CloudProviderBackoffMode,
                                "cloudProviderBackoff":              kubernetesConfig.CloudProviderBackoff,
                                "cloudProviderBackoffRetries":       kubernetesConfig.CloudProviderBackoffRetries,
                                "cloudProviderBackoffJitter":        strconv.FormatFloat(kubernetesConfig.CloudProviderBackoffJitter, 'f', -1, 64),
                                "cloudProviderBackoffDuration":      kubernetesConfig.CloudProviderBackoffDuration,
                                "cloudProviderBackoffExponent":      strconv.FormatFloat(kubernetesConfig.CloudProviderBackoffExponent, 'f', -1, 64),
                                "cloudProviderRateLimit":            kubernetesConfig.CloudProviderRateLimit,
                                "cloudProviderRateLimitQPS":         strconv.FormatFloat(kubernetesConfig.CloudProviderRateLimitQPS, 'f', -1, 64),
                                "cloudProviderRateLimitQPSWrite":    strconv.FormatFloat(kubernetesConfig.CloudProviderRateLimitQPSWrite, 'f', -1, 64),
                                "cloudProviderRateLimitBucket":      kubernetesConfig.CloudProviderRateLimitBucket,
                                "cloudProviderRateLimitBucketWrite": kubernetesConfig.CloudProviderRateLimitBucketWrite,
                                "cloudProviderDisableOutboundSNAT":  kubernetesConfig.CloudProviderDisableOutboundSNAT,
                        })
                        addValue(parametersMap, "kubeClusterCidr", kubernetesConfig.ClusterSubnet)
                        addValue(parametersMap, "dockerBridgeCidr", kubernetesConfig.DockerBridgeSubnet)
                        addValue(parametersMap, "networkPolicy", kubernetesConfig.NetworkPolicy)
                        addValue(parametersMap, "networkPlugin", kubernetesConfig.NetworkPlugin)
                        addValue(parametersMap, "networkMode", kubernetesConfig.NetworkMode)
                        addValue(parametersMap, "containerRuntime", kubernetesConfig.ContainerRuntime)
                        addValue(parametersMap, "containerdDownloadURLBase", cloudSpecConfig.KubernetesSpecConfig.ContainerdDownloadURLBase)
                        if config.IsARM64 </span><span class="cov8" title="1">{
                                addValue(parametersMap, "cniPluginsURL", cloudSpecConfig.KubernetesSpecConfig.CNIARM64PluginsDownloadURL)
                                addValue(parametersMap, "vnetCniLinuxPluginsURL", kubernetesConfig.GetAzureCNIURLARM64Linux(cloudSpecConfig))
                        }</span> else<span class="cov8" title="1"> {
                                addValue(parametersMap, "cniPluginsURL", cloudSpecConfig.KubernetesSpecConfig.CNIPluginsDownloadURL)
                                addValue(parametersMap, "vnetCniLinuxPluginsURL", kubernetesConfig.GetAzureCNIURLLinux(cloudSpecConfig))
                        }</span>
                        <span class="cov8" title="1">addValue(parametersMap, "vnetCniWindowsPluginsURL", kubernetesConfig.GetAzureCNIURLWindows(cloudSpecConfig))

                        if properties.HasWindows() </span><span class="cov8" title="1">{
                                addValue(parametersMap, "kubeBinariesSASURL", k8sComponents.WindowsPackageURL)

                                addValue(parametersMap, "windowsContainerdURL", kubernetesConfig.WindowsContainerdURL)
                                addValue(parametersMap, "kubeServiceCidr", kubernetesConfig.ServiceCIDR)
                                addValue(parametersMap, "kubeBinariesVersion", k8sVersion)
                                addValue(parametersMap, "windowsTelemetryGUID", cloudSpecConfig.KubernetesSpecConfig.WindowsTelemetryGUID)
                                addValue(parametersMap, "windowsSdnPluginURL", kubernetesConfig.WindowsSdnPluginURL)

                        }</span>
                }

                <span class="cov8" title="1">servicePrincipalProfile := properties.ServicePrincipalProfile

                if servicePrincipalProfile != nil </span><span class="cov8" title="1">{
                        addValue(parametersMap, "servicePrincipalClientId", servicePrincipalProfile.ClientID)
                        encodedServicePrincipalClientSecret := base64.StdEncoding.EncodeToString([]byte(servicePrincipalProfile.Secret))
                        addValue(parametersMap, "servicePrincipalClientSecret", servicePrincipalProfile.Secret)
                        // base64 encoding is to escape special characters like quotes in service principal
                        // reference: https://github.com/Azure/aks-engine/pull/1174
                        addValue(parametersMap, "encodedServicePrincipalClientSecret", encodedServicePrincipalClientSecret)
                }</span>

                /**
                 The following parameters could be either a plain text, or referenced to a secret in a keyvault:
                 - apiServerCertificate
                 - clientCertificate
                 - clientPrivateKey
                 - kubeConfigCertificate
                 - kubeConfigPrivateKey
                 - servicePrincipalClientSecret

                 To refer to a keyvault secret, the value of the parameter in the api model file should be formatted as:

                 "&lt;PARAMETER&gt;": "/subscriptions/&lt;SUB_ID&gt;/resourceGroups/&lt;RG_NAME&gt;/providers/Microsoft.KeyVault/vaults/&lt;KV_NAME&gt;/secrets/&lt;NAME&gt;[/&lt;VERSION&gt;]"
                 where:
                   &lt;SUB_ID&gt; is the subscription ID of the keyvault
                   &lt;RG_NAME&gt; is the resource group of the keyvault
                   &lt;KV_NAME&gt; is the name of the keyvault
                   &lt;NAME&gt; is the name of the secret.
                   &lt;VERSION&gt; (optional) is the version of the secret (default: the latest version)

                 This will generate a reference block in the parameters file:

                 "reference": {
                   "keyVault": {
                     "id": "/subscriptions/&lt;SUB_ID&gt;/resourceGroups/&lt;RG_NAME&gt;/providers/Microsoft.KeyVault/vaults/&lt;KV_NAME&gt;"
                   },
                   "secretName": "&lt;NAME&gt;"
                   "secretVersion": "&lt;VERSION&gt;"
                }
                **/

                <span class="cov8" title="1">certificateProfile := properties.CertificateProfile
                if certificateProfile != nil </span><span class="cov8" title="1">{
                        addSecret(parametersMap, "apiServerCertificate", certificateProfile.APIServerCertificate, true)
                        addSecret(parametersMap, "caCertificate", certificateProfile.CaCertificate, true)
                        addSecret(parametersMap, "clientCertificate", certificateProfile.ClientCertificate, true)
                        addSecret(parametersMap, "clientPrivateKey", certificateProfile.ClientPrivateKey, true)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package agent

import (
        "bytes"
        "compress/gzip"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "text/template"

        "github.com/Azure/agentbaker/pkg/agent/datamodel"
        "github.com/Azure/agentbaker/pkg/templates"
        "github.com/Azure/go-autorest/autorest/to"
        "github.com/blang/semver"
)

// TranslatedKubeletConfigFlags represents kubelet flags that will be translated into config file (if kubelet config file is enabled)
var TranslatedKubeletConfigFlags map[string]bool = map[string]bool{
        "--address":                           true,
        "--anonymous-auth":                    true,
        "--client-ca-file":                    true,
        "--authentication-token-webhook":      true,
        "--authorization-mode":                true,
        "--pod-manifest-path":                 true,
        "--cluster-dns":                       true,
        "--cgroups-per-qos":                   true,
        "--tls-cert-file":                     true,
        "--tls-private-key-file":              true,
        "--tls-cipher-suites":                 true,
        "--cluster-domain":                    true,
        "--max-pods":                          true,
        "--eviction-hard":                     true,
        "--node-status-update-frequency":      true,
        "--node-status-report-frequency":      true,
        "--image-gc-high-threshold":           true,
        "--image-gc-low-threshold":            true,
        "--event-qps":                         true,
        "--pod-max-pids":                      true,
        "--enforce-node-allocatable":          true,
        "--streaming-connection-idle-timeout": true,
        "--rotate-certificates":               true,
        "--read-only-port":                    true,
        "--feature-gates":                     true,
        "--protect-kernel-defaults":           true,
        "--resolv-conf":                       true,
        "--system-reserved":                   true,
        "--kube-reserved":                     true,
        "--cpu-manager-policy":                true,
        "--cpu-cfs-quota":                     true,
        "--cpu-cfs-quota-period":              true,
        "--topology-manager-policy":           true,
        "--allowed-unsafe-sysctls":            true,
        "--fail-swap-on":                      true,
        "--container-log-max-size":            true,
        "--container-log-max-files":           true,
}

var keyvaultSecretPathRe *regexp.Regexp

func init() <span class="cov8" title="1">{
        keyvaultSecretPathRe = regexp.MustCompile(`^(/subscriptions/\S+/resourceGroups/\S+/providers/Microsoft.KeyVault/vaults/\S+)/secrets/([^/\s]+)(/(\S+))?$`)
}</span>

type paramsMap map[string]interface{}

func addValue(m paramsMap, k string, v interface{}) <span class="cov8" title="1">{
        m[k] = paramsMap{
                "value": v,
        }
}</span>

func addKeyvaultReference(m paramsMap, k string, vaultID, secretName, secretVersion string) <span class="cov0" title="0">{
        m[k] = paramsMap{
                "reference": &amp;datamodel.KeyVaultRef{
                        KeyVault: datamodel.KeyVaultID{
                                ID: vaultID,
                        },
                        SecretName:    secretName,
                        SecretVersion: secretVersion,
                },
        }
}</span>

func addSecret(m paramsMap, k string, v interface{}, encode bool) <span class="cov8" title="1">{
        str, ok := v.(string)
        if !ok </span><span class="cov0" title="0">{
                addValue(m, k, v)
                return
        }</span>
        <span class="cov8" title="1">parts := keyvaultSecretPathRe.FindStringSubmatch(str)
        if parts == nil || len(parts) != 5 </span><span class="cov8" title="1">{
                if encode </span><span class="cov8" title="1">{
                        addValue(m, k, base64.StdEncoding.EncodeToString([]byte(str)))
                }</span> else<span class="cov0" title="0"> {
                        addValue(m, k, str)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov0" title="0">addKeyvaultReference(m, k, parts[1], parts[2], parts[4])</span>
}

func makeAgentExtensionScriptCommands(cs *datamodel.ContainerService, profile *datamodel.AgentPoolProfile) string <span class="cov0" title="0">{
        if profile.OSType == datamodel.Windows </span><span class="cov0" title="0">{
                return makeWindowsExtensionScriptCommands(profile.PreprovisionExtension,
                        cs.Properties.ExtensionProfiles)
        }</span>
        <span class="cov0" title="0">return makeExtensionScriptCommands(profile.PreprovisionExtension,
                "", cs.Properties.ExtensionProfiles)</span>
}

func makeExtensionScriptCommands(extension *datamodel.Extension, curlCaCertOpt string, extensionProfiles []*datamodel.ExtensionProfile) string <span class="cov0" title="0">{
        var extensionProfile *datamodel.ExtensionProfile
        for _, eP := range extensionProfiles </span><span class="cov0" title="0">{
                if strings.EqualFold(eP.Name, extension.Name) </span><span class="cov0" title="0">{
                        extensionProfile = eP
                        break</span>
                }
        }

        <span class="cov0" title="0">if extensionProfile == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%s extension referenced was not found in the extension profile", extension.Name))</span>
        }

        <span class="cov0" title="0">extensionsParameterReference := fmt.Sprintf("parameters('%sParameters')", extensionProfile.Name)
        scriptURL := getExtensionURL(extensionProfile.RootURL, extensionProfile.Name, extensionProfile.Version, extensionProfile.Script, extensionProfile.URLQuery)
        scriptFilePath := fmt.Sprintf("/opt/azure/containers/extensions/%s/%s", extensionProfile.Name, extensionProfile.Script)
        return fmt.Sprintf("- sudo /usr/bin/curl --retry 5 --retry-delay 10 --retry-max-time 30 -o %s --create-dirs %s \"%s\" \n- sudo /bin/chmod 744 %s \n- sudo %s ',%s,' &gt; /var/log/%s-output.log",
                scriptFilePath, curlCaCertOpt, scriptURL, scriptFilePath, scriptFilePath, extensionsParameterReference, extensionProfile.Name)</span>
}

func makeWindowsExtensionScriptCommands(extension *datamodel.Extension, extensionProfiles []*datamodel.ExtensionProfile) string <span class="cov0" title="0">{
        var extensionProfile *datamodel.ExtensionProfile
        for _, eP := range extensionProfiles </span><span class="cov0" title="0">{
                if strings.EqualFold(eP.Name, extension.Name) </span><span class="cov0" title="0">{
                        extensionProfile = eP
                        break</span>
                }
        }

        <span class="cov0" title="0">if extensionProfile == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%s extension referenced was not found in the extension profile", extension.Name))</span>
        }

        <span class="cov0" title="0">scriptURL := getExtensionURL(extensionProfile.RootURL, extensionProfile.Name, extensionProfile.Version, extensionProfile.Script, extensionProfile.URLQuery)
        scriptFileDir := fmt.Sprintf("$env:SystemDrive:/AzureData/extensions/%s", extensionProfile.Name)
        scriptFilePath := fmt.Sprintf("%s/%s", scriptFileDir, extensionProfile.Script)
        return fmt.Sprintf("New-Item -ItemType Directory -Force -Path \"%s\" ; curl.exe --retry 5 --retry-delay 0 -L \"%s\" -o \"%s\" ; powershell \"%s `\"',parameters('%sParameters'),'`\"\"\n", scriptFileDir, scriptURL, scriptFilePath, scriptFilePath, extensionProfile.Name)</span>
}

func escapeSingleLine(escapedStr string) string <span class="cov8" title="1">{
        // template.JSEscapeString leaves undesirable chars that don't work with pretty print
        escapedStr = strings.Replace(escapedStr, "\\", "\\\\", -1)
        escapedStr = strings.Replace(escapedStr, "\r\n", "\\n", -1)
        escapedStr = strings.Replace(escapedStr, "\n", "\\n", -1)
        escapedStr = strings.Replace(escapedStr, "\"", "\\\"", -1)
        return escapedStr
}</span>

// getBase64EncodedGzippedCustomScript will return a base64 of the CSE
func getBase64EncodedGzippedCustomScript(csFilename string, config *datamodel.NodeBootstrappingConfiguration) string <span class="cov8" title="1">{
        b, err := templates.Asset(csFilename)
        if err != nil </span><span class="cov0" title="0">{
                // this should never happen and this is a bug
                panic(fmt.Sprintf("BUG: %s", err.Error()))</span>
        }
        // translate the parameters
        <span class="cov8" title="1">templ := template.New("ContainerService template").Option("missingkey=error").Funcs(getContainerServiceFuncMap(config))
        _, err = templ.Parse(string(b))
        if err != nil </span><span class="cov0" title="0">{
                // this should never happen and this is a bug
                panic(fmt.Sprintf("BUG: %s", err.Error()))</span>
        }
        <span class="cov8" title="1">var buffer bytes.Buffer
        templ.Execute(&amp;buffer, config.ContainerService)
        csStr := buffer.String()
        csStr = strings.Replace(csStr, "\r\n", "\n", -1)
        return getBase64EncodedGzippedCustomScriptFromStr(csStr)</span>
}

// getBase64EncodedGzippedCustomScriptFromStr will return a base64-encoded string of the gzip'd source data
func getBase64EncodedGzippedCustomScriptFromStr(str string) string <span class="cov8" title="1">{
        var gzipB bytes.Buffer
        w := gzip.NewWriter(&amp;gzipB)
        w.Write([]byte(str))
        w.Close()
        return base64.StdEncoding.EncodeToString(gzipB.Bytes())
}</span>

func getExtensionURL(rootURL, extensionName, version, fileName, query string) string <span class="cov0" title="0">{
        extensionsDir := "extensions"
        url := rootURL + extensionsDir + "/" + extensionName + "/" + version + "/" + fileName
        if query != "" </span><span class="cov0" title="0">{
                url += "?" + query
        }</span>
        <span class="cov0" title="0">return url</span>
}

func getSSHPublicKeysPowerShell(linuxProfile *datamodel.LinuxProfile) string <span class="cov8" title="1">{
        str := ""
        if linuxProfile != nil </span><span class="cov8" title="1">{
                lastItem := len(linuxProfile.SSH.PublicKeys) - 1
                for i, publicKey := range linuxProfile.SSH.PublicKeys </span><span class="cov8" title="1">{
                        str += `"` + strings.TrimSpace(publicKey.KeyData) + `"`
                        if i &lt; lastItem </span><span class="cov0" title="0">{
                                str += ", "
                        }</span>
                }
        }
        <span class="cov8" title="1">return str</span>
}

// IsSgxEnabledSKU determines if an VM SKU has SGX driver support
func IsSgxEnabledSKU(vmSize string) bool <span class="cov0" title="0">{
        switch vmSize </span>{
        case "Standard_DC2s", "Standard_DC4s":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetCloudTargetEnv determines and returns whether the region is a sovereign cloud which
// have their own data compliance regulations (China/Germany/USGov) or standard
// Azure public cloud
func GetCloudTargetEnv(location string) string <span class="cov8" title="1">{
        loc := strings.ToLower(strings.Join(strings.Fields(location), ""))
        switch </span>{
        case strings.HasPrefix(loc, "china"):<span class="cov8" title="1">
                return "AzureChinaCloud"</span>
        case loc == "germanynortheast" || loc == "germanycentral":<span class="cov0" title="0">
                return "AzureGermanCloud"</span>
        case strings.HasPrefix(loc, "usgov") || strings.HasPrefix(loc, "usdod"):<span class="cov0" title="0">
                return "AzureUSGovernmentCloud"</span>
        default:<span class="cov8" title="1">
                return "AzurePublicCloud"</span>
        }
}

// IsKubernetesVersionGe returns true if actualVersion is greater than or equal to version
func IsKubernetesVersionGe(actualVersion, version string) bool <span class="cov8" title="1">{
        v1, _ := semver.Make(actualVersion)
        v2, _ := semver.Make(version)
        return v1.GE(v2)
}</span>

func getCustomDataFromJSON(jsonStr string) string <span class="cov8" title="1">{
        var customDataObj map[string]string
        err := json.Unmarshal([]byte(jsonStr), &amp;customDataObj)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return customDataObj["customData"]</span>
}

// GetOrderedKubeletConfigFlagString returns an ordered string of key/val pairs
// copied from AKS-Engine and filter out flags that already translated to config file
func GetOrderedKubeletConfigFlagString(k map[string]string, cs *datamodel.ContainerService, profile *datamodel.AgentPoolProfile, kubeletConfigFileToggleEnabled bool) string <span class="cov8" title="1">{
        // NOTE(mainred): kubeConfigFile now relies on CustomKubeletConfig, while custom configuration is not compatible
        // with CustomKubeletConfig. When custom configuration is set we want to override every configuration with the
        // customized one.
        kubeletCustomConfigurations := getKubeletCustomConfiguration(cs.Properties)
        if kubeletCustomConfigurations != nil </span><span class="cov8" title="1">{
                return getOrderedKubeletConfigFlagWithCustomConfigurationString(kubeletCustomConfigurations, k)
        }</span>

        <span class="cov8" title="1">if k == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        // Always force remove of dynamic-config-dir.
        <span class="cov8" title="1">kubeletConfigFileEnabled := IsKubeletConfigFileEnabled(cs, profile, kubeletConfigFileToggleEnabled)
        keys := []string{}
        for key := range k </span><span class="cov8" title="1">{
                if !kubeletConfigFileEnabled || !TranslatedKubeletConfigFlags[key] </span><span class="cov8" title="1">{
                        if !datamodel.CommandLineOmittedKubeletConfigFlags[key] </span><span class="cov8" title="1">{
                                keys = append(keys, key)
                        }</span>
                }
        }
        <span class="cov8" title="1">sort.Strings(keys)
        var buf bytes.Buffer
        for _, key := range keys </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("%s=%s ", key, k[key]))
        }</span>
        <span class="cov8" title="1">return buf.String()</span>
}

func getOrderedKubeletConfigFlagWithCustomConfigurationString(customConfig, defaultConfig map[string]string) string <span class="cov8" title="1">{
        config := customConfig

        for k, v := range defaultConfig </span><span class="cov8" title="1">{
                // add key-value only when the flag does not exist in custom config
                if _, ok := config[k]; !ok </span><span class="cov8" title="1">{
                        config[k] = v
                }</span>
        }

        <span class="cov8" title="1">keys := []string{}
        for key := range config </span><span class="cov8" title="1">{
                if !datamodel.CommandLineOmittedKubeletConfigFlags[key] </span><span class="cov8" title="1">{
                        keys = append(keys, key)
                }</span>
        }
        <span class="cov8" title="1">sort.Strings(keys)
        var buf bytes.Buffer
        for _, key := range keys </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("%s=%s ", key, config[key]))
        }</span>
        <span class="cov8" title="1">return buf.String()</span>
}

func getKubeletCustomConfiguration(properties *datamodel.Properties) map[string]string <span class="cov8" title="1">{
        if properties.CustomConfiguration == nil || properties.CustomConfiguration.KubernetesConfigurations == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">kubeletConfigurations, ok := properties.CustomConfiguration.KubernetesConfigurations["kubelet"]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if kubeletConfigurations.Config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // empty config is treated as nil
        <span class="cov8" title="1">if len(kubeletConfigurations.Config) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return kubeletConfigurations.Config</span>
}

// IsKubeletConfigFileEnabled get if dynamic kubelet is supported in AKS and toggle is on
func IsKubeletConfigFileEnabled(cs *datamodel.ContainerService, profile *datamodel.AgentPoolProfile, kubeletConfigFileToggleEnabled bool) bool <span class="cov8" title="1">{
        // TODO(bowa) remove toggle when backfill
        // If customKubeletConfig or customLinuxOSConfig is used (API20201101 and later), use kubelet config file
        return profile.CustomKubeletConfig != nil || profile.CustomLinuxOSConfig != nil ||
                (kubeletConfigFileToggleEnabled &amp;&amp; cs.Properties.OrchestratorProfile.IsKubernetes() &amp;&amp;
                        IsKubernetesVersionGe(cs.Properties.OrchestratorProfile.OrchestratorVersion, "1.14.0"))
}</span>

// IsKubeletClientTLSBootstrappingEnabled get if kubelet client TLS bootstrapping is enabled
func IsKubeletClientTLSBootstrappingEnabled(tlsBootstrapToken *string) bool <span class="cov8" title="1">{
        return tlsBootstrapToken != nil
}</span>

// GetTLSBootstrapTokenForKubeConfig returns the TLS bootstrap token for kubeconfig usage.
// It returns empty string if TLS bootstrap token is not enabled.
//
// ref: https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration
func GetTLSBootstrapTokenForKubeConfig(tlsBootstrapToken *string) string <span class="cov8" title="1">{
        if tlsBootstrapToken == nil </span><span class="cov8" title="1">{
                // not set
                return ""
        }</span>

        <span class="cov8" title="1">return *tlsBootstrapToken</span>
}

// GetKubeletConfigFileContent converts kubelet flags we set to a file, and return the json content
func GetKubeletConfigFileContent(kc map[string]string, customKc *datamodel.CustomKubeletConfig) string <span class="cov8" title="1">{
        if kc == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        // translate simple values
        <span class="cov8" title="1">kubeletConfig := &amp;datamodel.AKSKubeletConfiguration{
                APIVersion:    "kubelet.config.k8s.io/v1beta1",
                Kind:          "KubeletConfiguration",
                Address:       kc["--address"],
                StaticPodPath: kc["--pod-manifest-path"],
                Authorization: datamodel.KubeletAuthorization{
                        Mode: datamodel.KubeletAuthorizationMode(kc["--authorization-mode"]),
                },
                ClusterDNS:                     strings.Split(kc["--cluster-dns"], ","),
                CgroupsPerQOS:                  strToBoolPtr(kc["--cgroups-per-qos"]),
                TLSCertFile:                    kc["--tls-cert-file"],
                TLSPrivateKeyFile:              kc["--tls-private-key-file"],
                TLSCipherSuites:                strings.Split(kc["--tls-cipher-suites"], ","),
                ClusterDomain:                  kc["--cluster-domain"],
                MaxPods:                        strToInt32(kc["--max-pods"]),
                NodeStatusUpdateFrequency:      datamodel.Duration(kc["--node-status-update-frequency"]),
                NodeStatusReportFrequency:      datamodel.Duration(kc["--node-status-report-frequency"]),
                ImageGCHighThresholdPercent:    strToInt32Ptr(kc["--image-gc-high-threshold"]),
                ImageGCLowThresholdPercent:     strToInt32Ptr(kc["--image-gc-low-threshold"]),
                EventRecordQPS:                 strToInt32Ptr(kc["--event-qps"]),
                PodPidsLimit:                   strToInt64Ptr(kc["--pod-max-pids"]),
                EnforceNodeAllocatable:         strings.Split(kc["--enforce-node-allocatable"], ","),
                StreamingConnectionIdleTimeout: datamodel.Duration(kc["--streaming-connection-idle-timeout"]),
                RotateCertificates:             strToBool(kc["--rotate-certificates"]),
                ReadOnlyPort:                   strToInt32(kc["--read-only-port"]),
                ProtectKernelDefaults:          strToBool(kc["--protect-kernel-defaults"]),
                ResolverConfig:                 kc["--resolv-conf"],
                ContainerLogMaxSize:            kc["--container-log-max-size"],
        }

        // Authentication
        kubeletConfig.Authentication = datamodel.KubeletAuthentication{}
        if ca := kc["--client-ca-file"]; ca != "" </span><span class="cov8" title="1">{
                kubeletConfig.Authentication.X509 = datamodel.KubeletX509Authentication{
                        ClientCAFile: ca,
                }
        }</span>
        <span class="cov8" title="1">if aw := kc["--authentication-token-webhook"]; aw != "" </span><span class="cov8" title="1">{
                kubeletConfig.Authentication.Webhook = datamodel.KubeletWebhookAuthentication{
                        Enabled: strToBool(aw),
                }
        }</span>
        <span class="cov8" title="1">if aa := kc["--anonymous-auth"]; aa != "" </span><span class="cov8" title="1">{
                kubeletConfig.Authentication.Anonymous = datamodel.KubeletAnonymousAuthentication{
                        Enabled: strToBool(aa),
                }
        }</span>

        // EvictionHard
        // default: "memory.available&lt;750Mi,nodefs.available&lt;10%,nodefs.inodesFree&lt;5%"
        <span class="cov8" title="1">if eh, ok := kc["--eviction-hard"]; ok &amp;&amp; eh != "" </span><span class="cov8" title="1">{
                kubeletConfig.EvictionHard = strKeyValToMap(eh, ",", "&lt;")
        }</span>

        // feature gates
        // look like "f1=true,f2=true"
        <span class="cov8" title="1">kubeletConfig.FeatureGates = strKeyValToMapBool(kc["--feature-gates"], ",", "=")

        // system reserve and kube reserve
        // looks like "cpu=100m,memory=1638Mi"
        kubeletConfig.SystemReserved = strKeyValToMap(kc["--system-reserved"], ",", "=")
        kubeletConfig.KubeReserved = strKeyValToMap(kc["--kube-reserved"], ",", "=")

        // Settings from customKubeletConfig, only take if it's set
        if customKc != nil </span><span class="cov8" title="1">{
                if customKc.CPUManagerPolicy != "" </span><span class="cov8" title="1">{
                        kubeletConfig.CPUManagerPolicy = customKc.CPUManagerPolicy
                }</span>
                <span class="cov8" title="1">if customKc.CPUCfsQuota != nil </span><span class="cov8" title="1">{
                        kubeletConfig.CPUCFSQuota = customKc.CPUCfsQuota
                }</span>
                <span class="cov8" title="1">if customKc.CPUCfsQuotaPeriod != "" </span><span class="cov8" title="1">{
                        kubeletConfig.CPUCFSQuotaPeriod = datamodel.Duration(customKc.CPUCfsQuotaPeriod)
                        // enable CustomCPUCFSQuotaPeriod feature gate is required for this configuration
                        kubeletConfig.FeatureGates["CustomCPUCFSQuotaPeriod"] = true
                }</span>
                <span class="cov8" title="1">if customKc.TopologyManagerPolicy != "" </span><span class="cov8" title="1">{
                        kubeletConfig.TopologyManagerPolicy = customKc.TopologyManagerPolicy
                        // enable TopologyManager feature gate is required for this configuration
                        kubeletConfig.FeatureGates["TopologyManager"] = true
                }</span>
                <span class="cov8" title="1">if customKc.ImageGcHighThreshold != nil </span><span class="cov8" title="1">{
                        kubeletConfig.ImageGCHighThresholdPercent = customKc.ImageGcHighThreshold
                }</span>
                <span class="cov8" title="1">if customKc.ImageGcLowThreshold != nil </span><span class="cov8" title="1">{
                        kubeletConfig.ImageGCLowThresholdPercent = customKc.ImageGcLowThreshold
                }</span>
                <span class="cov8" title="1">if customKc.AllowedUnsafeSysctls != nil </span><span class="cov8" title="1">{
                        kubeletConfig.AllowedUnsafeSysctls = *customKc.AllowedUnsafeSysctls
                }</span>
                <span class="cov8" title="1">if customKc.FailSwapOn != nil </span><span class="cov8" title="1">{
                        kubeletConfig.FailSwapOn = customKc.FailSwapOn
                }</span>
                <span class="cov8" title="1">if customKc.ContainerLogMaxSizeMB != nil </span><span class="cov8" title="1">{
                        kubeletConfig.ContainerLogMaxSize = fmt.Sprintf("%dM", *customKc.ContainerLogMaxSizeMB)
                }</span>
                <span class="cov8" title="1">if customKc.ContainerLogMaxFiles != nil </span><span class="cov8" title="1">{
                        kubeletConfig.ContainerLogMaxFiles = customKc.ContainerLogMaxFiles
                }</span>
                <span class="cov8" title="1">if customKc.PodMaxPids != nil </span><span class="cov8" title="1">{
                        kubeletConfig.PodPidsLimit = to.Int64Ptr(int64(*customKc.PodMaxPids))
                }</span>
        }

        <span class="cov8" title="1">configStringByte, _ := json.MarshalIndent(kubeletConfig, "", "    ")
        return string(configStringByte)</span>
}

func strToBool(str string) bool <span class="cov8" title="1">{
        b, _ := strconv.ParseBool(str)
        return b
}</span>

func strToBoolPtr(str string) *bool <span class="cov8" title="1">{
        if str == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">b := strToBool(str)
        return &amp;b</span>
}

func strToInt32(str string) int32 <span class="cov8" title="1">{
        i, _ := strconv.ParseInt(str, 10, 32)
        return int32(i)
}</span>

func strToInt32Ptr(str string) *int32 <span class="cov8" title="1">{
        if str == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">i := strToInt32(str)
        return &amp;i</span>
}

func strToInt64(str string) int64 <span class="cov8" title="1">{
        i, _ := strconv.ParseInt(str, 10, 64)
        return i
}</span>

func strToInt64Ptr(str string) *int64 <span class="cov8" title="1">{
        if str == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">i := strToInt64(str)
        return &amp;i</span>
}

func strKeyValToMap(str string, strDelim string, pairDelim string) map[string]string <span class="cov8" title="1">{
        m := make(map[string]string)
        pairs := strings.Split(str, strDelim)
        for _, pairRaw := range pairs </span><span class="cov8" title="1">{
                pair := strings.Split(pairRaw, pairDelim)
                if len(pair) == 2 </span><span class="cov8" title="1">{
                        key := strings.TrimSpace(pair[0])
                        val := strings.TrimSpace(pair[1])
                        m[key] = val
                }</span>
        }
        <span class="cov8" title="1">return m</span>
}

func strKeyValToMapBool(str string, strDelim string, pairDelim string) map[string]bool <span class="cov8" title="1">{
        m := make(map[string]bool)
        pairs := strings.Split(str, strDelim)
        for _, pairRaw := range pairs </span><span class="cov8" title="1">{
                pair := strings.Split(pairRaw, pairDelim)
                if len(pair) == 2 </span><span class="cov8" title="1">{
                        key := strings.TrimSpace(pair[0])
                        val := strings.TrimSpace(pair[1])
                        m[key] = strToBool(val)
                }</span>
        }
        <span class="cov8" title="1">return m</span>
}

func removeFeatureGateString(featureGates string, key string) string <span class="cov8" title="1">{
        fgMap := strKeyValToMapBool(featureGates, ",", "=")
        delete(fgMap, key)
        keys := make([]string, 0, len(fgMap))
        for k := range fgMap </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        pairs := make([]string, 0, len(keys))
        for _, k := range keys </span><span class="cov8" title="1">{
                pairs = append(pairs, fmt.Sprintf("%s=%t", k, fgMap[k]))
        }</span>
        <span class="cov8" title="1">return strings.Join(pairs, ",")</span>
}

func addFeatureGateString(featureGates string, key string, value bool) string <span class="cov8" title="1">{
        fgMap := strKeyValToMapBool(featureGates, ",", "=")
        fgMap[key] = value
        keys := make([]string, 0, len(fgMap))
        for k := range fgMap </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        pairs := make([]string, 0, len(keys))
        for _, k := range keys </span><span class="cov8" title="1">{
                pairs = append(pairs, fmt.Sprintf("%s=%t", k, fgMap[k]))
        }</span>
        <span class="cov8" title="1">return strings.Join(pairs, ",")</span>
}

// ParseCSEMessage parses the raw CSE output
func ParseCSEMessage(message string) (*datamodel.CSEStatus, *datamodel.CSEStatusParsingError) <span class="cov8" title="1">{
        start := strings.Index(message, "[stdout]") + len("[stdout]")
        end := strings.Index(message, "[stderr]")
        if end &gt; start </span><span class="cov8" title="1">{
                return parseLinuxCSEMessage(message, start, end)
        }</span> else<span class="cov8" title="1"> if strings.Contains(message, "Command execution finished") </span><span class="cov8" title="1">{
                return parseWindowsCSEMessage(message)
        }</span>
        <span class="cov8" title="1">return nil, datamodel.NewError(datamodel.InvalidCSEMessage, message)</span>
}

func parseLinuxCSEMessage(message string, start int, end int) (*datamodel.CSEStatus, *datamodel.CSEStatusParsingError) <span class="cov8" title="1">{
        // Linux CSE message example: Enable succeeded: \n[stdout]\n{ \"ExitCode\": \"0\", \"Output\": \"Tue Dec 28" } }\n\n[stderr]\nBootup is not yet finished. Please try again later.
        var cseStatus datamodel.CSEStatus
        rawInstanceViewInfo := message[start:end]
        err := json.Unmarshal([]byte(rawInstanceViewInfo), &amp;cseStatus)
        if err != nil </span><span class="cov8" title="1">{
                return nil, datamodel.NewError(datamodel.CSEMessageUnmarshalError, message)
        }</span>
        <span class="cov8" title="1">if cseStatus.ExitCode == "" </span><span class="cov8" title="1">{
                return nil, datamodel.NewError(datamodel.CSEMessageExitCodeEmptyError, message)
        }</span>
        <span class="cov8" title="1">return &amp;cseStatus, nil</span>
}

func parseWindowsCSEMessage(message string) (*datamodel.CSEStatus, *datamodel.CSEStatusParsingError) <span class="cov8" title="1">{
        // Windows CSE message example: Command execution finished, but failed because it returned a non-zero exit code of: '1'.
        var cseStatus datamodel.CSEStatus
        re := regexp.MustCompile(`a non-zero exit code of: '(\d+)'`)
        match := re.FindStringSubmatch(message)
        if match != nil </span><span class="cov8" title="1">{
                cseStatus.ExitCode = match[1]
        }</span> else<span class="cov8" title="1"> {
                cseStatus.ExitCode = "0"
        }</span>
        <span class="cov8" title="1">cseStatus.Output = message
        return &amp;cseStatus, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

package agent

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/Azure/agentbaker/pkg/agent/datamodel"
        "github.com/blang/semver"
)

var dockerShimFlags = []string{"--cni-bin-dir", "--cni-cache-dir", "--cni-conf-dir", "--docker-endpoint", "--image-pull-progress-deadline", "--network-plugin", "--network-plugin-mtu"}

// getCustomDataVariables returns cloudinit data used by Linux
func getCustomDataVariables(config *datamodel.NodeBootstrappingConfiguration) paramsMap <span class="cov8" title="1">{
        cs := config.ContainerService
        cloudInitFiles := map[string]interface{}{
                "cloudInitData": paramsMap{
                        "provisionStartScript":         getBase64EncodedGzippedCustomScript(kubernetesCSEStartScript, config),
                        "provisionScript":              getBase64EncodedGzippedCustomScript(kubernetesCSEMainScript, config),
                        "provisionSource":              getBase64EncodedGzippedCustomScript(kubernetesCSEHelpersScript, config),
                        "provisionSourceUbuntu":        getBase64EncodedGzippedCustomScript(kubernetesCSEHelpersScriptUbuntu, config),
                        "provisionSourceMariner":       getBase64EncodedGzippedCustomScript(kubernetesCSEHelpersScriptMariner, config),
                        "provisionInstalls":            getBase64EncodedGzippedCustomScript(kubernetesCSEInstall, config),
                        "provisionInstallsUbuntu":      getBase64EncodedGzippedCustomScript(kubernetesCSEInstallUbuntu, config),
                        "provisionInstallsMariner":     getBase64EncodedGzippedCustomScript(kubernetesCSEInstallMariner, config),
                        "provisionConfigs":             getBase64EncodedGzippedCustomScript(kubernetesCSEConfig, config),
                        "provisionSendLogs":            getBase64EncodedGzippedCustomScript(kubernetesCSESendLogs, config),
                        "provisionRedactCloudConfig":   getBase64EncodedGzippedCustomScript(kubernetesCSERedactCloudConfig, config),
                        "customSearchDomainsScript":    getBase64EncodedGzippedCustomScript(kubernetesCustomSearchDomainsScript, config),
                        "dhcpv6SystemdService":         getBase64EncodedGzippedCustomScript(dhcpv6SystemdService, config),
                        "dhcpv6ConfigurationScript":    getBase64EncodedGzippedCustomScript(dhcpv6ConfigurationScript, config),
                        "kubeletSystemdService":        getBase64EncodedGzippedCustomScript(kubeletSystemdService, config),
                        "reconcilePrivateHostsScript":  getBase64EncodedGzippedCustomScript(reconcilePrivateHostsScript, config),
                        "reconcilePrivateHostsService": getBase64EncodedGzippedCustomScript(reconcilePrivateHostsService, config),
                        "ensureNoDupEbtablesScript":    getBase64EncodedGzippedCustomScript(ensureNoDupEbtablesScript, config),
                        "ensureNoDupEbtablesService":   getBase64EncodedGzippedCustomScript(ensureNoDupEbtablesService, config),
                        "bindMountScript":              getBase64EncodedGzippedCustomScript(bindMountScript, config),
                        "bindMountSystemdService":      getBase64EncodedGzippedCustomScript(bindMountSystemdService, config),
                        "migPartitionSystemdService":   getBase64EncodedGzippedCustomScript(migPartitionSystemdService, config),
                        "migPartitionScript":           getBase64EncodedGzippedCustomScript(migPartitionScript, config),
                        "containerdKubeletDropin":      getBase64EncodedGzippedCustomScript(containerdKubeletDropin, config),
                        "cgroupv2KubeletDropin":        getBase64EncodedGzippedCustomScript(cgroupv2KubeletDropin, config),
                        "componentConfigDropin":        getBase64EncodedGzippedCustomScript(componentConfigDropin, config),
                        "tlsBootstrapDropin":           getBase64EncodedGzippedCustomScript(tlsBootstrapDropin, config),
                        "bindMountDropin":              getBase64EncodedGzippedCustomScript(bindMountDropin, config),
                        "httpProxyDropin":              getBase64EncodedGzippedCustomScript(httpProxyDropin, config),
                        "componentManifestFile":        getBase64EncodedGzippedCustomScript(componentManifestFile, config),
                },
        }

        cloudInitData := cloudInitFiles["cloudInitData"].(paramsMap)
        if cs.IsAKSCustomCloud() </span><span class="cov8" title="1">{
                // TODO(ace): do we care about both? 2nd one should be more general and catch custom VHD for mariner
                if config.AgentPoolProfile.Distro.IsCBLMarinerDistro() || isMariner(config.OSSKU) </span><span class="cov0" title="0">{
                        cloudInitData["initAKSCustomCloud"] = getBase64EncodedGzippedCustomScript(initAKSCustomCloudMarinerScript, config)
                }</span> else<span class="cov8" title="1"> {
                        cloudInitData["initAKSCustomCloud"] = getBase64EncodedGzippedCustomScript(initAKSCustomCloudScript, config)
                }</span>
        }

        <span class="cov8" title="1">if !cs.Properties.IsVHDDistroForAllNodes() </span><span class="cov8" title="1">{
                cloudInitData["provisionCIS"] = getBase64EncodedGzippedCustomScript(kubernetesCISScript, config)
                cloudInitData["kmsSystemdService"] = getBase64EncodedGzippedCustomScript(kmsSystemdService, config)
                cloudInitData["aptPreferences"] = getBase64EncodedGzippedCustomScript(aptPreferences, config)
                cloudInitData["healthMonitorScript"] = getBase64EncodedGzippedCustomScript(kubernetesHealthMonitorScript, config)
                cloudInitData["kubeletMonitorSystemdService"] = getBase64EncodedGzippedCustomScript(kubernetesKubeletMonitorSystemdService, config)
                cloudInitData["dockerMonitorSystemdService"] = getBase64EncodedGzippedCustomScript(kubernetesDockerMonitorSystemdService, config)
                cloudInitData["dockerMonitorSystemdTimer"] = getBase64EncodedGzippedCustomScript(kubernetesDockerMonitorSystemdTimer, config)
                cloudInitData["containerdMonitorSystemdService"] = getBase64EncodedGzippedCustomScript(kubernetesContainerdMonitorSystemdService, config)
                cloudInitData["containerdMonitorSystemdTimer"] = getBase64EncodedGzippedCustomScript(kubernetesContainerdMonitorSystemdTimer, config)
                cloudInitData["dockerClearMountPropagationFlags"] = getBase64EncodedGzippedCustomScript(dockerClearMountPropagationFlags, config)
        }</span>

        <span class="cov8" title="1">return cloudInitFiles</span>
}

// getWindowsCustomDataVariables returns custom data for Windows
// TODO(qinhao): combine this function with `getCSECommandVariables` after we support passing variables from cse command to customdata
func getWindowsCustomDataVariables(config *datamodel.NodeBootstrappingConfiguration) paramsMap <span class="cov8" title="1">{
        cs := config.ContainerService
        // these variables is subet of
        customData := map[string]interface{}{
                "tenantID":                             config.TenantID,
                "subscriptionId":                       config.SubscriptionID,
                "resourceGroup":                        config.ResourceGroupName,
                "location":                             cs.Location,
                "vmType":                               cs.Properties.GetVMType(),
                "subnetName":                           cs.Properties.GetSubnetName(),
                "nsgName":                              cs.Properties.GetNSGName(),
                "virtualNetworkName":                   cs.Properties.GetVirtualNetworkName(),
                "routeTableName":                       cs.Properties.GetRouteTableName(),
                "primaryAvailabilitySetName":           cs.Properties.GetPrimaryAvailabilitySetName(),
                "primaryScaleSetName":                  config.PrimaryScaleSetName,
                "useManagedIdentityExtension":          useManagedIdentity(cs),
                "useInstanceMetadata":                  useInstanceMetadata(cs),
                "loadBalancerSku":                      cs.Properties.OrchestratorProfile.KubernetesConfig.LoadBalancerSku,
                "excludeMasterFromStandardLB":          true,
                "windowsEnableCSIProxy":                cs.Properties.WindowsProfile.IsCSIProxyEnabled(),
                "windowsCSIProxyURL":                   cs.Properties.WindowsProfile.CSIProxyURL,
                "windowsProvisioningScriptsPackageURL": cs.Properties.WindowsProfile.ProvisioningScriptsPackageURL,
                "windowsPauseImageURL":                 cs.Properties.WindowsProfile.WindowsPauseImageURL,
                "alwaysPullWindowsPauseImage":          strconv.FormatBool(cs.Properties.WindowsProfile.IsAlwaysPullWindowsPauseImage()),
                "windowsCalicoPackageURL":              cs.Properties.WindowsProfile.WindowsCalicoPackageURL,
                "windowsSecureTlsEnabled":              cs.Properties.WindowsProfile.IsWindowsSecureTlsEnabled(),
                "windowsGmsaPackageUrl":                cs.Properties.WindowsProfile.WindowsGmsaPackageUrl,
                "windowsCSEScriptsPackageURL":          cs.Properties.WindowsProfile.CseScriptsPackageURL,
                "isDisableWindowsOutboundNat":          strconv.FormatBool(config.AgentPoolProfile.IsDisableWindowsOutboundNat()),
        }

        return customData
}</span>

func getCSECommandVariables(config *datamodel.NodeBootstrappingConfiguration) paramsMap <span class="cov8" title="1">{
        cs := config.ContainerService
        profile := config.AgentPoolProfile
        return map[string]interface{}{
                "tenantID":                        config.TenantID,
                "subscriptionId":                  config.SubscriptionID,
                "resourceGroup":                   config.ResourceGroupName,
                "location":                        cs.Location,
                "vmType":                          cs.Properties.GetVMType(),
                "subnetName":                      cs.Properties.GetSubnetName(),
                "nsgName":                         cs.Properties.GetNSGName(),
                "virtualNetworkName":              cs.Properties.GetVirtualNetworkName(),
                "virtualNetworkResourceGroupName": cs.Properties.GetVNetResourceGroupName(),
                "routeTableName":                  cs.Properties.GetRouteTableName(),
                "primaryAvailabilitySetName":      cs.Properties.GetPrimaryAvailabilitySetName(),
                "primaryScaleSetName":             config.PrimaryScaleSetName,
                "useManagedIdentityExtension":     useManagedIdentity(cs),
                "useInstanceMetadata":             useInstanceMetadata(cs),
                "loadBalancerSku":                 cs.Properties.OrchestratorProfile.KubernetesConfig.LoadBalancerSku,
                "excludeMasterFromStandardLB":     true,
                "maximumLoadBalancerRuleCount":    getMaximumLoadBalancerRuleCount(cs),
                "userAssignedIdentityID":          config.UserAssignedIdentityClientID,
                "isVHD":                           isVHD(profile),
                "gpuNode":                         strconv.FormatBool(config.EnableNvidia),
                "sgxNode":                         strconv.FormatBool(datamodel.IsSgxEnabledSKU(profile.VMSize)),
                "configGPUDriverIfNeeded":         config.ConfigGPUDriverIfNeeded,
                "enableGPUDevicePluginIfNeeded":   config.EnableGPUDevicePluginIfNeeded,
                "migNode":                         strconv.FormatBool(datamodel.IsMIGNode(config.GPUInstanceProfile)),
                "gpuInstanceProfile":              config.GPUInstanceProfile,
        }
}</span>

func useManagedIdentity(cs *datamodel.ContainerService) string <span class="cov8" title="1">{
        useManagedIdentity := cs.Properties.OrchestratorProfile.KubernetesConfig != nil &amp;&amp;
                cs.Properties.OrchestratorProfile.KubernetesConfig.UseManagedIdentity
        return strconv.FormatBool(useManagedIdentity)
}</span>

func useInstanceMetadata(cs *datamodel.ContainerService) string <span class="cov8" title="1">{
        useInstanceMetadata := cs.Properties.OrchestratorProfile.KubernetesConfig != nil &amp;&amp;
                cs.Properties.OrchestratorProfile.KubernetesConfig.UseInstanceMetadata != nil &amp;&amp;
                *cs.Properties.OrchestratorProfile.KubernetesConfig.UseInstanceMetadata
        return strconv.FormatBool(useInstanceMetadata)
}</span>

func getMaximumLoadBalancerRuleCount(cs *datamodel.ContainerService) int <span class="cov8" title="1">{
        if cs.Properties.OrchestratorProfile.KubernetesConfig != nil </span><span class="cov8" title="1">{
                return cs.Properties.OrchestratorProfile.KubernetesConfig.MaximumLoadBalancerRuleCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func isVHD(profile *datamodel.AgentPoolProfile) string <span class="cov8" title="1">{
        //NOTE: update as new distro is introduced
        return strconv.FormatBool(profile.IsVHDDistro())
}</span>

func getOutBoundCmd(nbc *datamodel.NodeBootstrappingConfiguration, cloudSpecConfig *datamodel.AzureEnvironmentSpecConfig) string <span class="cov8" title="1">{
        cs := nbc.ContainerService
        if cs.Properties.FeatureFlags.IsFeatureEnabled("BlockOutboundInternet") </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">registry := ""
        if cloudSpecConfig.CloudName == datamodel.AzureChinaCloud </span><span class="cov0" title="0">{
                registry = `gcr.azk8s.cn`
        }</span> else<span class="cov8" title="1"> if cs.IsAKSCustomCloud() </span><span class="cov8" title="1">{
                registry = cs.Properties.CustomCloudEnv.McrURL
        }</span> else<span class="cov8" title="1"> {
                registry = `mcr.microsoft.com`
        }</span>

        <span class="cov8" title="1">if registry == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // curl on Ubuntu 16.04 (shipped prior to AKS 1.18) doesn't support proxy TLS
        // so we need to use nc for the connectivity check
        <span class="cov8" title="1">clusterVersion, _ := semver.Make(cs.Properties.OrchestratorProfile.OrchestratorVersion)
        minVersion, _ := semver.Make("1.18.0")

        connectivityCheckCommand := ""
        if clusterVersion.GTE(minVersion) </span><span class="cov8" title="1">{
                connectivityCheckCommand = `curl -v --insecure --proxy-insecure https://` + registry + `/v2/`
        }</span> else<span class="cov8" title="1"> {
                connectivityCheckCommand = `nc -vz ` + registry + ` 443`
        }</span>

        <span class="cov8" title="1">return connectivityCheckCommand</span>
}

func getProxyVariables(nbc *datamodel.NodeBootstrappingConfiguration) string <span class="cov8" title="1">{
        // only use https proxy, if user doesn't specify httpsProxy we autofill it with value from httpProxy
        proxyVars := ""
        if nbc.HTTPProxyConfig != nil </span><span class="cov8" title="1">{
                if nbc.HTTPProxyConfig.HTTPProxy != nil </span><span class="cov8" title="1">{
                        // from https://curl.se/docs/manual.html, curl uses http_proxy but uppercase for others?
                        proxyVars = fmt.Sprintf("export http_proxy=\"%s\";", *nbc.HTTPProxyConfig.HTTPProxy)
                }</span>
                <span class="cov8" title="1">if nbc.HTTPProxyConfig.HTTPSProxy != nil </span><span class="cov8" title="1">{
                        proxyVars = fmt.Sprintf("export HTTPS_PROXY=\"%s\"; %s", *nbc.HTTPProxyConfig.HTTPSProxy, proxyVars)
                }</span>
                <span class="cov8" title="1">if nbc.HTTPProxyConfig.NoProxy != nil </span><span class="cov8" title="1">{
                        proxyVars = fmt.Sprintf("export NO_PROXY=\"%s\"; %s", strings.Join(*nbc.HTTPProxyConfig.NoProxy, ","), proxyVars)
                }</span>
        }
        <span class="cov8" title="1">return proxyVars</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
